import express from 'express';
import bodyParser from 'body-parser';
import session from 'express-session';
import crypto from 'crypto';
import memorystore from 'memorystore';
import multer from 'multer';
import fs from 'fs';
import {Chart} from 'chart.js';
import csvParser from 'csv-parser';


const PORT = 8080;
const app = express();
const upload = multer({ dest: 'uploads/' }); // Set the destination folder for uploaded files

app.listen(PORT, () => {
  console.log(`Server is ready, listening on port ${PORT}`);
});

app.set('view engine', 'ejs');
app.use(express.static('public'));
app.use(express.static('images'));
app.use(bodyParser.urlencoded({ extended: true }));

const MemoryStore = memorystore(session);

app.set('trust proxy', 1);
app.use(
  session({
    cookie: { maxAge: 86400000 },
    store: new MemoryStore({
      checkPeriod: 86400000, // prune expired entries every 24h
    }),
    resave: false,
    saveUninitialized: false,
    secret: 'keyboard cat',
  })
);

//DATABASE CONNECTION-------------------------------------------------------------------------------------------
import mysql from 'mysql'

const pool = mysql.createPool({
    user: 'root',
    password: '',
    database: 'bagbook',
    host: 'localhost'

});

const dbConnect = () => {
    return new Promise((resolve, reject) => {
        pool.getConnection((err, conn) => {
            if(err){
                reject (err);
            }
            else{
                resolve(conn);
            }
        }
        )
    })
};
//==============================================================================================================

//FOR AUTHENTICATION-----------------------------------------------------------------------------------------
const auth = (req, res, next) => {
  if (req.session.username) {
    next();
  } else {
    res.redirect('/');
  }
};
//==============================================================================================================



//PAGE PERTAMA YANG MUNCUL (LOG IN) --------------------------------------------------------------------------------
let showAlert = false;
app.get('/', (req, res) => {
  res.render('log_in_public', {
    showAlert,
  });
  showAlert = false;
});
//==============================================================================================================


//LOG IN (memeriksa apakah username & password yg diinput user benar)-----------------------------------------------
app.post('/log_in_public', (req, res) => {
  //mengambil username dan password yg diinput user
  let username = req.body.username;
  let password = crypto.createHash('sha256').update(req.body.password).digest('base64');
  //cek apakah username dan password tidak kosong
  if (username && password) {
    userLogin(username, password).then((data) => {
      //cek apakah username&pass benar
      let res_data = JSON.parse(JSON.stringify(data))[0];
      //jika username&pass benar
      if (res_data !== undefined) {
        showAlert = false;
        //tambahkan session
        let session = req.session;
        //tambahkan data user ke session
        session.username = res_data.username;
        //mengubah pass yg dikirimkan menjadi hash dengan algo sha256
        session.password = res_data.password;
        session.photo = res_data.user_photo;
        session.full_name = res_data.full_name;
        session.email = res_data.email;
        session.idUser = res_data.idUser;
        //status = 1 (publik), 0(admin)
        session.status = res_data.status;
        //jika yang login adalah user publik
        if (session.status === 1) {
          //halaman berpindah ke halaman utama (users)
          res.redirect('/dashboard_public');
        } else {
          //halaman berpindah ke dashboard admin
          res.redirect('/dashboard_admin');
        }
      }
      //jika data yang didapatkan kosong = username dan/atau password salah
      else {
        showAlert = true;
        res.redirect('/');
      }
    });
    }
});

const userLogin = (username, pass) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT * FROM user WHERE username = ? AND password = ?', [username, pass], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//==============================================================================================================


//SIGN UP ------------------------------------------------------------------------------------------------------
//membuka halaman sign up
app.get('/sign_up_public', (req, res)=>{
    res.render('sign_up_public')
})

//memasukan data user baru ke database
let email_sign_up;
app.post('/submit_user', (req, res)=>{
    //mengambil full_name, email, username, dan password yg diregister oleh user
    let full_name_sign_up = req.body.full_name;
    email_sign_up = req.body.email_address;
    let username_sign_up = req.body.username_sign_up;
    let password_sign_up = crypto.createHash('sha256').update(req.body.password_sign_up).digest('base64');
    addUser(full_name_sign_up, email_sign_up, username_sign_up, password_sign_up).then(() => 
        res.redirect('/verify_email')
    )
})

//masukan ke database
const addUser = (full_name_sign_up, email_sign_up, username_sign_up, password_sign_up) => {
    return new Promise((resolve, reject) => {
        pool.query('INSERT INTO user (full_name, email, username, password, user_photo) VALUES (?,?,?,?, 0x89504e470d0a1a0a0000000d4948445200000200000002000806000000f478d4fa0000000473424954080808087c086488000000097048597300000ec400000ec401952b0e1b0000001974455874536f667477617265007777772e696e6b73636170652e6f72679bee3c1a0000200049444154789cecdd799854d59dfff1f7a9ea0d68a077e86e9abd51c17d0137165134266aa29364b22f1393986526c66c93cccc2f99cc923d9add244e268999c93ad9344edc50c005dc50082eecd0d0ddf44eb3f656dfdf1f17276880aeaebe55e756d5e7f53cfda058f7dc8f58d6f9d639e79e03222222222222222222222222222222222222222222222222222222222222221215ce77001119de8e1e2b2f1c6412096a8851658e3207652428738e328332a014188f310647093001a30047d9cb9a9b08c45ef67b0960ef4b7ec7e8c13100ecc3388ce310b0efc84f8f193d2e468f418f337a48d0418cf6be38ad33ca5d4f3afe1c44243c2a00443cdab6cd4a0ac631a5c03105c7548306600a8e068cc9c024a00628f29b74c4fa8076a0d5a0d5c12e829f9dced8194bb0abb7975d8d8daecf6f4c91fca5024024cd9a9a6c8c2be6a4789cd90963963366e3980dcc02a690bfff1f1a4151b019c76633b638c7e6c4209bad9f8d0d0dee90ef8022b92c5f3f784442d7d46463e225ccc531d7c13c60aec15c60067f39e42e279600b639d860f02cb001e3d9befd3c3b63863bec3b9c482e5001209282ce4e9bd0e7381de31c602e09e6e1381728f69d2dc70d021b810d663c0b3ce98a79b46e82ebf09c4b24eba8001019869915b6747086732c305840f033c7772ef93f465014ac71b0c68c35b5553ce39c1bf41d4c24ca540088bc4c57974dec1be2621c8bccb808c7d9c018dfb964440e613ce91c0f936065519c872a2b5dafef502251a20240f25ed35eab880fb018580c2c024e07e27e5349c88680a7315699e3c1c102564e2b73ddbe4389f8a40240f28e9915b4747086392e73701941c75fe83b9764540258ebe0be04dc77b09b557a2451f28d0a00c90b2ddd363d31c455ce7125c662609cef4c1229fb71ac70c65d16e70f75e56e87ef4022e9a60240729299c55a3a38cbe06ae7b80a381bbddf25598ead18771adc5157c9835a5028b9481f889233366db2e2d2895c6a8eeb8057e3a8f29d4972423bc6ef5c9c5f779573ff3ce7fa7d071209830a00c96adbb659495129cb9ce375c03504fbdc8ba44b0f70af833be3097e5d53e3f6fb0e24922a15009275cc2cdedcc9250ede06bc0618ef3b93e4a543c09d66dc5e57c51f9d7303be03898c840a00c91acded760e8eb7017f4d70488e485474017f30f8715d25f73be7cc772091e1a80090486beeb6692ec1db0dde8e31d3771e91246c017e688e1fd557ba26df61448e47058044ceb66d56523281ab13c6db1c5c8936e591ec94c07814f8716c88ff9a3cd91df01d48e4682a0024325abbecd4a1043738780b5acc27b9a5c7c1ed386eadad74cffa0e23022a00c4b30d6645155dbcda8cf70097a2f7a4e4be2731be377498db1b1adc21df61247fe9c356bcd8d96e75058e0f02ef026a7ce711f1a00db86dd0f8d6d46ad7ec3b8ce41f150092514d5d767adcf800c6db8012df794422a01ff8792cc6972657b8f5bec348fe50012019d1dc65175b824f3878157adf891c9bf1b0c117eaaab8538f124abae98358d2e6a8f9fd8f01e7f9ce23922d9cb1cee05b7dfbf9f18c19eeb0ef3c929b540048e83a3b6d421fbc13e3234083ef3c2259acd58cef268af87ac344d7e53b8ce4161500129ab6369b3ce8f8048eeb8152df794472c83e8cefc7137c71d224b7c77718c90d2a0064d476f55aa5ebe36f9de326b42fbf483a1d046e8b0ff1ef2a0464b4540048cadadb6d7cbfe3fd0e3e8936ee11c9a4fd0ebed55fc017a695b96edf61243ba90090116b6bb3d281181f70f0f74099ef3c22796c9f836f17c7f85c4585dbeb3b8c6417150092b4d6561b9728e47a8c4fa2d3f844a2a4d38c6f96c4f86a65a5ebf51d46b2830a00195653938d898fe5068cbf47bbf68944d91e1c9fefebe5563d3e28c351012027b4bbddae76f0351c337c671191a4ed72f00f932bb95d1b0ac9f1a80090636a6eb7b389710bc642df594424656b628e1b2757bad5be8348f4a800909768eeb52afaf927e00340dc771e1119b504f05f05093e5e53e35a7d8791e8500120009859614b17efc7f82c30c1771e1109dd0133be7cb087cf3536ba3edf61c43f150012ccf33b6e0666f9ce2222e9e560338e4fd556ba5fface227ea900c863ad5d76da50825b1c2cf59d454432ee5ee7f8706da5dbe03b88f8a102200f6ddb662545a5fcbd737c1228f29d4744bc1974f095c3fbf88c1e1bcc3f2a00f24c739b2d24c6f780937d671191c8d81283f74cae72cb7d0791cc51019027baba6ce2e1049f053e08c47ce71191c831e0274385dca8a387f3830a803c706491dfb78129beb38848e4b53ac7dfd656ba5ff90e22e9a5022087b5b5d9e4c118df005eeb3b8b886417833bcdf1be29956e97ef2c921e1a0ace4166e65a3aec6d833136a0ce5f4452e0e0aa98f1a7e64efb9099a9afc8411a01c831cddd368d217e082cf11c45447284c1721cefa8af744dbeb3487854d5e590964e7b2d433c853a7f11099183a5ce58dfdc6e6ff69d45c2a311801cd0d96913fae04b18eff19d454472de2ffbe2bc6746b9ebf11d4446470540966bedb005063f3198ed3b8b88e48dedc4786b5d857bc87710499da600b2949915eceeb04f2460953a7f11c9b0e92478a0a5c33e6f6685bec3486a340290855aba6dba0d723b8e8b7d671191bcb76628c15b1a6adc66df416464340290655a3aed7536c45a75fe2212110be2319e6c6e37ad41ca321a01c812adad362e51c8f731dee83b8b88c871dc4e3f37d4d5b983be83c8f054006481a6369b1d8ff16be034df5944444ec419eb6209ae9b34c96df19d454e4c530011d7d26eaf8ac7780c75fe229205cc71fa509ca79a3bec35beb3c889a90088283373bb3bec13e6f83d50ee3b8f88c8084c007e7de42901f53311a5298008eaecb4097dc68f8157fbce2222322a8ebb06e2bc655a99ebf61d455e4a0540c4ecda6367c40af835c64cdf594444c2e060f3608cbf6aa870eb7c67913fd3d04c8434b7db9b63711e51e72f22b9c460763cc19a960e7b87ef2cf2672a0022c0cc0a5a3aec1b387e028cf59d4744240d4a0cfeb3b9dd6e36b3b8ef30a22900efdadaac7430cecf305ee53b8b884886dc53ec785d65a5ebf51d249fa900f06867bbd51538ee00cef69d454424939cb12e11e3aafa4ad7e43b4bbe5201e0496b979d9648702730d5771611111f1c3427125c555fe3d6face928fb406c083dd9db62c916015eafc45248f19d4b9182b5bdaec95beb3e423150019b6bbd3fec6197f0026face22221201a516e377cded7683ef20f9460540869899dbdd6e9f71c67f003a3f5b44e4cf0a707ca7b9c3bea69d0333476b003260d3262b1e57ce0f8037f9ce22221271bf1a3ac4db1a1adc21df41729d0a8034dbd66d65c583dc89e322df594444b282636589e39a8a0ab7d777945ca602208d9af65a457c80ff05e6fbce222292659ea2882bea26b80edf4172950a8034696bb3c98331ee41c7f88a88a4eab941e3b2a9d5aed977905ca402200d9abb6c2a09ee031a7d671111c96ac6b67882cb264d725b7d47c9355a6d19b2d61e9bc1100fa2ce5f4464f41c3386e23cd0d466fa4c0d99460042d4dc61a738b8cfa0ce771611911cb3271663d9e40ab7de77905ca111809034b7dbd9182bd5f98b88a4c5a44482152d1da645d52151011082960e3b0fc7bd38aa7c671111c961e506f7ecee323d561d024d018c526b872d4dc0ef8171beb348feea1b84f603477ef643d721d8d707fbfb61ff915ffb87e0607ff0fac144700d40511c0a8f9cce3ea6104a0aa0b408c6154369314c2c868ab1503d16aac6417569708d8847079c71756db57bc077906ca60260147675da0531e31ea0d47716c90ffd43b06b2f3475c3cedee0d75d7ba1b72fb339cac640c344985a06f513a1a12cf8fb028d294ae61c24c12bea6adc2adf41b2950a8014ed6ab33363319603e5beb348eeea39042fb4c3a64ed8d4013bba836fef51541883199530a7121aaba0b11a2614fb4e25396e2fc66575d5ee09df41b2910a8014b476d9a989040f0295beb3486e1948c0c63658bf0736b4c2b66edf8946a77e229c5507a74d82936a344220696074b8184b6a2bdd06df51b28d0a80116a6ab3d9f1182b815adf5924371cec872776c3e33b61435b30cc9f8bc614c0197530bf01ceacd33a0209559b198beaabdd0bbe836413150023b0bbd31a9cb11298ee3b8b64b7c383f0d46e787407ac6f8deeb07eba14c5e1ac7a387f2a9c5d0b711503327a4d2ecea2da72b7dd77906ca10220497bf6d8a4a1382b80937c6791ecb56b2f3cb41d1ed80a0732bc702faac615c18206b8b411a695f94e23d9ccc1e602635175b56bf19d251ba800484273af55d1cf83c03cdf5924fbf40f059dfef2cdb03dcbe7f4d36d76255c3e279826d07a0149d19f12452c9932c175fa0e12752a0086d1d565130f27b81f38c77716c92ebd7db0722bfc7163b09a5f925756024b67c3e58dc15e042223e2787a20ced269654e25f709a80038816ddbaca4b894fb7068d729495ac701f8fdb3b06a5bb0aa5f5257140f0a81ab4e098a0291a439561ee8e2f2c646a7c9b6e35001701c66e65a3ab91d78b3ef2c921d7afbe0aee7e1ee17d4f187ad20068b66c075a7069b108924c38c5fd455f106e79cf9ce12452a008ea3a5c33e6ff009df3924fa0ef4c16f9f85fb36a9e34fb7a2385c3107ae991b6c5b2c92847fadab72ffe43b4414a9003886dd9df62e67dce63b8744db5002566c835fadcbfc56bcf9aeb418ae9d0bcbe6404c9f62321ce37d75d5ee56df31a246ffebbc4c73a7bd02e30ea0c0771689aef5adf093b5b07bafef24f9ada10cde7a36ccadf19d44226e00c7557595ee1edf41a24405c0518e6cf1fb1030d1771689a6de3ef8efb5c1637d121d0ba6c23bce81f17a62408e6f5f6288855326b9677c07890a150047ec6cb7ba02c76aa0c1771689a6353be1874f06c7ec4af48c2b86bf3e1d96cef29d44226c77c271fe944ab7cb779028500100b4b7dbf881182b31cef49d45a2a7fb107cff3158a7bdc5b2c2597570fd7c98a8c706e5d89e2a48b0b8a6c6edf71dc4b7bc2f00cc2cdedac96f0caef69d45a2e7895d70dbe3b05fdffab3ca846278d77c38a7de77128924e37f6babb8c63937e83b8a4f795f00b474d8370c3ee83b8744cbe141b87d2dacd8e23b898cc6d259f096b375f2a01c83714b5db5fbb0ef183ee57501d0dc6e6fc6f113df39245a9a7be19687825f25fb3594c18d17c1a4f1be9348d43878476d95fb91ef1cbee46d01d0d465a7c7133c0a8cf59d45a2e3a9dd70eb6a3838e03b8984694c01bc7b4170c890c8510e59828bea6bdc5adf417cc8cb0260478f95170ef238a0f5c20240c2e017ebe00fcf81f60ccd4d0eb87a2ebcee347079f9c927c7e260f3e138e7cd28773dbeb3645ade1db86966b1c201fe0b75fe7244df20dcbc0aee54e79fd38ce090a65b1e0e8e68160130985d34c4ed669677fd61defd0bb774f2cf38aef49d43a2a1fb30fcebfdb0b6d97712c9942777c167ee85ae83be93485438b8aab58b7ff09d23d3f26a206c77bb5ded1cbf250f0b1ff94b4d7be1cb2ba1f380ef24e243d538f8e82298a27d3f25907009aeaead7177f90e922979530034b559633cc6634099ef2ce2dfd62ef8e20a3ddf9fefc6150545406395ef241211ddf121ce9b34c9e5c503c0795100b4b6dab84401ab81537d6711ff9e6f87afac84435ae92f4049017c7821cc9be43b89448133d6d90017d4d5b99c9f24ca8ba1f04421df479dbf106ce7fbc507d5f9cb9f1d1e0c0a426df52c00e6389d22beed3b4726e47c01d0d261efc078a3ef1ce2dfba16f8ea2aad0097bfd43f14bc37d6b7fa4e2211f1f6e6767b93ef10e996d353007bf6d8cca1386b8109beb3885f1bdbe10b2b8247fe448ea7280e1f5b02a754fb4e2211b0d7c539b3b6dc6df71d245d727604c0cc0a12717e823affbcb7b913bea4ce5f92d03f045f5d192c1295bc37d106f98999e5ec4912395b003477f04f0617f8ce217e35ed0d3aff43eafc2549870682274476eff59d44bc735cd4d2c9277dc748979c9c02d8dd6517b9042b809caddc6478dd87e19fef850e3de72f29a81e079f5e066525be9388678331c7c2c9956eb5ef2061cbb91180b6362b8d25f821eafcf35aff10dcb24a9dbfa4aefd007c455347020509f8aff676cbb9f32473ae00188cf11d83d9be73883f09836f3c0c5b3a7d27916cb7ad1bbeb31a4c8744e43763e6a0e316df31c2965305404ba7bd16788bef1ce2d72fd6696f7f09cf13bbe097eb7da710df0cfe6677a7fdb5ef1c61ca99026057a74d31e37bbe73885f4fee0e8ef41509d31dcfc2e3bb7ca710df9c716b73974df59d232c39510098998b19b703e5beb3883f2dfbe0d6d53ad257c267c0f7564373afef24e259994bf00333cb8905f4395100b474f01e6089ef1ce2cfe141b87995b6f895f4393408df78443b49e63b834b9bbb7887ef1c61c8fa02a0bddd6a717cce770ef1ebf6b5fa7626e9d7d4033f5deb3b85f8e68c9b77b65b9def1ca395f505c080e35b68e83faf3db10b56e4c5e19d1205f76dd6225361621c6ef61d62b4b2ba0068eeb4bf02aef59d43fce93904b73dee3b85e41303bebf06f61ef69d447c728ed73777d86b7ce7188dac2d00baba6c22c6d77ce710bfbef718eceff39d42f24d6f1ffc870a4f816f6febb632df215295b505c0e121be0cd4fbce21feacdaa633dcc59fa776c3ea9dbe538867b54543fc9bef10a9caca02a0a5dd16e37897ef1ce2cfbe3ef8e9d3be5348befbd193c17b51f297831b9abbec62df3952917505c0a64d566c8e5bc9d1838c24393f7a32188615f1695f1ffc7c9def14e2598c04b76ddb6659776c54d61500a5e5fc3370b2ef1ce2cffa560dbd4a74acd802cfb7fb4e219e9d545ccaa77c8718a9ac2a005abbec34838ff8ce21fe0c25e0bff51cb64488013f7e3238844af298e3ef5b3a6daeef18239155054022c1578002df39c49ffb3643d35edf29445e6a670facdaea3b85785688f175df2146226b0a80e60ebb0e58e63b87f873a01f7eb3c1770a9163fbf93a6d459def0c2e6d6db7ab7ce748565614001bcc8a80cffbce217efd76839ef997e8eaed833b741265de4b386ed9b4c98a7de74846561400e59ddc0434face21fe741f86fb37fb4e217262776fd4d329c2ac71157cc077886444be00d8b3c726019ff49d43fcfafd9f740a9b445fdf20fc41a300627cbaadcd26fb8e319cc8170089389f0326f8ce21fe741e8007b4c04ab2c4bd9b744e80306130ce677c87184ea40b80dd6d7696c1db7de710bf7ef72c0c267ca710494eff10dcf9bcef14e29df1eee6763bc7778c13897401e0e27c8d886794f4eaed8387b6fb4e213232f76fd282552186e3cbbe439c48643bd7ddedf6068c85be73885ff76ed2dcbf649ffe217850d356024b8e3cc21e49912c009a9a6c8c737cc1770ef16b2001cbb5f25fb2d4dd1b35752580e34b517d2c309205407c2cef03a6face217eaddaa6c55492bdba0fc1634dbe538877c6ccb1e5bcdb778c63895c01d0da6ae3303eee3b87f8a76fff92edeedde83b814481834f3537db58df395e2e720540a280bf0526f9ce217e6ded82edddbe53888ccea64ed8a5b32b046a29e606df215e2e5205405b9b950237f9ce21fe3db8c577029170acd462400148f0c9f6761bef3bc6d12255000cc5f90850ed3b87f8d537088feef49d42241cabb66b31a0008eaa01c7077dc7385a640a806ddd5666c6877ce710ff9edcad53d52477eceb83b5cdbe5348447c7c5bb795f90ef1a2c81400c5437c0c28f79d43fc7b7487ef0422e15aa3112d09949524a2f3453712054073af55017feb3b87f877b01fd6b7fa4e2112aea77607535b22667cb869af55f8ce011129006c804f00915a1c217e3cb14bf3a5927bfa87e09916df29242226c607f888ef10108102a0adcd263be3fdbe7348343cae8d53244769532039ca875a5badc67708ef05c0a0e3e340e4364890cc1b48c08636df2944d2e399168d6ec9ff196705fe4701bc16003b7aac1c17cd2d1225f39edba3837f24771d1a802d9dbe53485418bcafabcb26facce0b500281ce406a0d46706898e67b4f84f72dc3abdc7e5cfc6f70d71bdcf00de0a00332b04cdfdcb9fadd3b3d292e3d66b21a01cc51c371ee90bbdf05600b476f266608aaffb4bb4f41c82967dbe5388a4d7b66ed8dfe73b8544c894960e5eefebe61e4700b8d1d7bd257a9e6ff79d4024fdcc606387ef1412250e3e6e66cec7bdbd1400cd9d76058e337cdc5ba269931647499ed8a402408e628ed37777b2d4c7bdfd8c0098ffc71f245a36690440f2840a0079b998a73e31e305406b979d065c96e9fb4a74f50fc1ce1edf294432636b97f6039097715cd9d465a767fab6192f0012093e0a7899ef9068dab5571f88923ffa8760f75edf29246a0a3c1c1294d1026067bbd5016fc8e43d25fa7676fb4e2092594d2a00e4650cdedcde6eb599bc67460b8002c70781a24cde53a24f1f86926ff49e9763281e7099dd1b276305c006b322e05d99ba9f640fcdff4bbed9adf7bc1cdbf599dc18286305407907af05bc9f7e24d1a3f950c9373bf59e97639bdcdcc19599ba5926a700de97c17b4996e81b845eed8c2679a6fb6070faa5c85fc8e001791929005a3a6d2e8e8b32712fc92e6d077c2710c93c033af5de976370706573974dcdc4bd325200248c0fa047ffe4183af4212879aa5def7d39b6b833de9e891ba5bd00686ab2310ede9ceefb48766adfef3b81881f2a00e478cc789799a5bd7f4efb0de2255c074c4cf77d243b751df29d40c40f8d7ec9094c6be96259ba6f92f602c039de99ee7b48f6daa7058092a7742cb09c90a57f31605a0b80e66e9b6670493aef21d94d1f8292aff6f7fb4e2011f7ea74ef0c98d602c025787bbaef21d96d9f3e04254f69f44b8651d0ef786b3a6f90b6ced9cc9c9199958c92bd340220f94a2300321c17ec0c98b627e8d25600b4747311c6cc74b52fb9e1f0a0ef04227e1c1cf09d40b240e39e4ee6a7abf1f48d00247863bada96dc3138e43b81881f7aef4b3212f0a674b59d9602c0cc0a1cbc361d6d4b6e19d476a892a7f4de9724bdc1cc0ad2d1705a0a80d60eae4007ff4812f42128f96a402300929c9a962e96a6a3e1f48c00b8f40d59486e510120f94aef7d4996597aa6d4432f009a9b6d2cf0eab0db151111c9470eaedbb6cd4ac26e37fc118062ae04c685deaee4a402ed1221794aef7d19810945a5e16f0d1cfe5bd0b82ef4362567e94350f25561dc7702c926cef15761b719eac7efa64d560cbc2acc3625b7a900907c55a8f7be8cccab37981585d960a86fc1d2322e4327ffc90814e85b90e4a9b8defb323265e55d2c09b3c1706bd0340c51486e2b49cbd3ad22d13756ef7d19b950fbd8d00a00338b1b5c15567b921fc617fb4e20e247a9defb3252c6abcd2cb47e3bb4865abab900a80eab3dc90ffa10947ca5e2575230694f27e785d558785300092dfe9391530120f9aa34d4e55c922f12165e5f1be61a80ab436c4bf2c4787d084a9e52f12b2971e14db58752003477db34605e186d497ea918e33b81881fe5637d27902c75e6ae4e9b124643a1140036c43561b423f9a7bad47702113f6a5400486a5c2ca429f7500a00e7784518ed48fea9d2a6d192a754fc4aca42ea73475d006c302bc258144618c93f352a00240f3954fccaa82c35b3c2d13632ea02a0a2830b01d5b29292e20298a0c5509267ca4aa0483b014aea2634778dfe71c0511700e6c23fa148f24b4399ef04229955aff7bc8c5682cb47db44186b005400c8a84cd187a1e499a93a314546c985f0e57b5405c08e1e2b07ce1e6d08c96f5327f84e2092591af59210ccefeab2519592a32a000a07b904d04c968c4a43b9ef042299355505808c5ec1a1a1d12dc01fed148056ffcba84d9908053a1b5df2443c0e759a029030c45838bacb474705808c5a511ca6691440f2c4cc722854c12b2170c6e2d15c9ff2dbf0c8dcc3e9a3b9b9c88b1aab7c2710c98c93f45e97f09cddde6ee353bd38e502a07f888568fe5f4232471f8a92271a7568ba84a76020c605a95e9c7201606e74730f22479ba30f45c9030e8d7649c82cf5be38f502002e4ef55a91972b2b813a3d0e28396e4a9976be94d0a5dc17a754001cd983f8ac546f2a722ca7d7fa4e20925e7a8f4b1a9c676605a95c985201d0d2c119804e7297509da10f47c9717a8f4b1a8cdbddcea9a95c98da0880e3fc54ae133991536a82c381447251718116bb4a7ac452ec93532a001c2c48e53a91132988c1dc1adf2944d2e3d4c9daf04ad2c35c6a7d72aa05804600242de64ff59d40243dced77b5bd224d53e79c405c0b66e2b339895cacd4486736ebd764993dc5318833335ff2fe973522a07038df8a3b66490b3081e671509dd9842384d1f949263ceaa0fdedb2269e20e0f8e7c67de11170016d3e37f925e1a2a955cb3a0c17702c97929f4cd231f6c351500925ee74e81b145be538884636c61300220924e96c2de3ca9ccb6aa0090b42a8ac3051a05901c71d1f4e03d2d924e2e852fe7232a009a9a6c0c70d2486f223252976a99a9e488257a2f4b2638e66eda6423da687a440540bc84b980b66a91b49b5a0ed3cb7da710199d991530adcc770ac91385632670f2482e185101e01cf346964724759736fa4e20323a1ac9924c7231e68ee4f5235d0330a2c6454663e1f4e09440916c34a1182e9ce13b85e413e75400488e2888c1d2d9be5388a4e68a39dad44a322e7d0580690a4032ec8a461d1024d9a7280e97aa7895cc1b511f9d7401d0dc6c6331a68f388ec8288c2b0ea60244b2c99259503aa2f5d822a19835922701922e001205cc19c9eb45c272f5293a454db247610cae1ad15a6c91d0148caf24e9e5d3497facc6e368404bbca81c07976835b56489cb1aa162acef1492af8612c91fd697740160a60240fcb9669e765393e82b2e80ab4ef19d42f2596c047d75f203aba62380c59ff212b84c25a844dcb24698a84757c52373691801c0690440fc7af53c18af85551251138ae11a3d282dfea5610460048d8aa4c3b822b8ee34df29448eed75670427ff897815f608c0b66d5602e8404bf1eed259d0a0bdd52562a695c162edfa2751604c33b3a44ad1a40a8082714c01dca842898420e6e02d67fa4e21f2670e78cbd9c17b532402e22d3dd425f3c2e40a0047c3e8f2888467de64b8709aef1422818533e0941adf29448e32c0d4645e96dc1a00150012316f3b3b587425e2d3f862788346a4246a92ecb3932a000c1500122da5c5f0a6b37ca7907cf7f67354884a04398d00488ebb783a9c5eeb3b85e4abb3eae0fca43e6645322bd92fedc93e063865145944d2e6bd0bb4f18a64de846278d77cdf29448e2d166a0160e87b9644d2c412f89bf37ca7907ce280772f8032159e1251069393795db223009346914524adcea987a5daa85a32e4b2c660f85f24c292eab3872d00cccc018580b8940000200049444154d5a38e2392466f3e0bea27fa4e21b9aea10cdea855ff127d493d983a6c01b0ab9772a068d47144d2a8b8006eba585bb14afa8c2d821b2fd6a99492154a3a3b6dc2702f1ab600880f68f85fb2c3a4f170c3f9dab252c2e780f7cc8749a5be938824e7e0d0f07df7f06b00121afe97ec71763d5cad13d92464af3915ced5b3509245e205611400711500925d5e7b5a50088884e1bc2970dd3cdf294446c612540ef79ae1170182ce5e93ac1273f0c10ba171d8b7bfc889cdac3832ada47925c932b124faee610b8058420580649fa2387c7891e66c2575d5a5f09145c10253916c632e8402c0400f5749569a500c372d8471daab5d46687c317c6c91769994ece5c21801704954112251553f113e7549f008974832c614c2c71643ddb00f5189449725317aaf350092f3a69505dfe64a34942bc3288a07c3fe332b7c2711199d50a60000d5c192f51aabe043174341b29b5f4bde298cc14716c2c97aee4972804b62fa3e998fc3b1216411f1eeb4c9f089251a0990bf5414879b16c1bca48e5011c902c698e15e327c01602a0024779c52031f5f1cccf38a40b07df4df2f090a44919c111bbeef1ebe00702a0024b7cca9864f2d0d567a4b7e1b57041f5f12bc2744724a125fde35052079694639fce352a81ee73b89f852330e3e7d19ccd68651929b5400881c4ffd44f8ece5faf6978f6655c2a797e9513fc969211400492c2410c956e38be19397c0f9537d27914c39770afcc3526df223396fd80260f8f5d00e2d97929c5618830f5c101c27fcfb0d60be03495a38e035f3e0ba53b5b7bfe48561fbf7641e888a87104424d29c83d79d06b3abe03b8fc2c17edf89244c630ae1bd0b74a4afe49561fbee64d600a80090bc71562d7c76194cd1091839a3a10cfef50a75fe927786edbb871d086beeb03e403ba94b5ee91f829f3f03f76cd4944036bb783abcf35c9de82779e9705d953be11abe640a8041340a20796a5d0b7c6f0df41cf69d4446624231bc7b019c55e73b898837037555ee845fde93290012c9bc4e2457f51c86dbd6c0d32dbe934832ceaa83ebe76b95bfe4bd445d953be19777150022495ab3137ef424f4f6f94e22c732a118de78162c9cee3b894824845200680a40e48803fdc1da8007b6686d40942c980aef3847db3b8b1c259429002d021479990d7be0276ba1a9c77792fc36ad0cde727670c89388bc44288b000f82760314793933786807fc74ada60532adb418ae9d0bcbe6404c139422c7b2bfaeca8d3fd10b922900f601a5a14512c93107fbe1f7cfc23d9b82c707257d8a0b6059235c333738c657448e6b6f5d952b3bd10b9229007a006d8b22328cde3eb8ebf960ef001502e18ac761f174b8f63428d7ea7e916474d555b9139e75994c01d006e8bc349124751d843b9e83155b55088c5671012c9e09579f02e59a88141989b6ba2a37e9442f48a600d80934841649244f1c1c80555be1cee7a1fb90ef34d96542315cd608973706f3fd223262dbebaadc8c13bd20990d320f86144624af8c2d842b4e82a58df0f03658be05b676f94e156d332be0d25970d10c2848e6a41211399e61fb6e1500226956188325b3829fdd7b61d57678702becd793034050289d3f152e9d0dd3ca7da711c919211400c641ed0328128efa89f086338233e99fda0dab77c233cd3090f09d2cb38ae270466db081cfd9f5c1df8b48885c180540128d88c8c814c5836fbde74f8543034131f0d82ed8d00a87077da74b8f9202387532cc6f80b3ea618c4ee813499f84a60044226f4c215c343df8194ac0964e78aa392806b67767f796c335e382cefeec3a38a946f3fa2219e31876e9713205c0de10a2884812e23198531dfc7046b0b7c0964ed8d6052f74c0c6b6e84e17c4633075e291fc5570caa46035bf88649e8361372a4fa600d06ee7229e4c280e8eb77df15cfb8104ecda0b4dddd0d40b3b7ba0b907ba0f673657d998603dc3d4326838f26bfdc460c1a388f86716420160468fd322409148288cc18cf2e0e768fd43d0be1fda0f06bf761f0a460ff6bff8d30ffd8370681012164c35bcb8d6a0a420f8f61e73c1bc7c71018c2b0a9ebf1f5f04e34ba07c2c548f0b86f4ab4bd5d18b449d8b855000b8183d593d092992078ae2c137f07a6dda2d22243702306c1d6f9a02101111c92ac9ac0118b60070495411222222121d09a37bb8d70c3f9397a033943422222292197186dd787cf82900c79e70d28888884826140cd03adc6b862d00fa0b54008888886493588cb6e15e93d4037ecd1d7618d0961e222222d177a8aeca8d1dee45c93ecddb3eca302222229219498ddc275b00681a404444243b0c3bfc0fc916006ef8c504222222e29f0b7504c0681a551a111111c9941dc9bc28d929001500222222592091649fad02404444249724396a9f5401e03405202222921de2ec4ce665491500b1840a001111916ce0c29c02e8ed65179018552211111149b7c1da729a93796152054063a3eb03768f2a92888888a49763a7736e30999726bb081060738a7144444424132cf9be3af902c0d8925218111111c9081bc197f5e40b00a70240444424cadc08faeaa40b00e7340520222212659648c308c0d0209b528b2322222299108ba5610460e0202f0043292512111191741bdcdf958611801933dc61607b2a8944444424ed361f796c3f2923790c10071b469e474444443260447df4880a00836747964544444432c246d6478fa800400580888848248df44bfac80a00d314808888481425e2692c000ef4b0011818512211111149b7fede729e1fc905232a008eac2e1cd10d44444424ed36cc73ae7f24178c740d00c0da14ae11111191347129f4cd232f009c0a001111912849a45000148cf4029760adb9915e2522a932837dfdb0bf0f0ef4c3fe237fbdbfffc8dff741df10f40fc1c17e181882be41383808830938fcb2553b03475e7bb49202881ffd75c0c1b823bf575200630aa1b020f8eb9242288a41693194161df5531cfc8c2f86b18569ff631191a3c532500014c558db6718a03240649412065d07a1ed00741e84ee83d07338f8bd177fed3d1c74e4e97478f02f7fef40d2fb89fda5c218948f81b2b1503e16ca4ba0720c4c1c035563a1a614cac6a4debe88bc849518eb477a514a9d787387bd00cc49e55a917c3398803dfb60772fb4ed3ff27300daf7079d7eba3bf7a82a8c41cd78a8190bd5e3a1661c4c1a0f751382bf76fa8a2192ac67ebaadcbc915e34e211802356a30240e42506134127dfdc0bbbf642cb915fdbf6e76f277f220309d8bd37f8a1e5a5ffac30067513a16e3c4c9918fc75c3449854aac240e4e55cd0278f584a05808335066f4be55a915c3034042dfb615b376ceffaf3af2f9f5b97d40c24604777f073b49202a81d0ff513614639cca880e9155014f79353240acc5893ca75a94d01b4db39389e48e55a916c63167c93dfdc059bda617327b4ec0b7e5ffc8bc7a161023456c2ecaae06752a9ef5422993314e38c860ab76ea4d7a554009859614b273dc0d854ae1789b243834147bfa9133675c0964e38a4fd2fb3cac412985d098d55c1cfac4a284865d71391e8db575b49b9736ec4e38f29cfa635b7db2a1c17a77abd4854f40f051dfe0b1dc1cff3edc110bfe48ea278305530a70a4e9b0427d5a82090dc60b0bcbeca5d9acab5a92e02c4391e36540048f6194a04dfea9f6985e7da606ba716e9e5bafe21d8d81efcdcf91c1417c049d530b7064e9f0c0de57aae59b293331e4ef9da542f6c69b3575a8c3fa47abd4826f5f6c1737b606d73f07360443b664bae9b500ca74c8233ebe0ec3a1857e43b914872cc71797da5bb37956b532e003a3b6d429fd10568fdad448e117ccb7f72173cd3023b7b7c27926c118f050b0acfa88373ea837d0944226ab0d0a8a8ae76fb52b97854a35ecd1df62470f668da10094bc2607307ac6982c77705bbe8898c56cd3838ab1e16344063b5a60a243a0c56d757b90b52bd3ee5350047eebe02a70240fc194cc033cdf0d82e785a43fb92066d07e0ee8dc14fc5d86054607e039c5cad4d89c4af18ac1ccdf5a31d01b816f8f568da101929b3e0f1bc354df0c80ed8378a3deb4552553e262804343220bec48cab2757bb3b53bd7e54efd96ddd56563c44075a072019b0ad1b1eda066b760607e5884445d5b8606460d10c9856ee3b8de489c192185515156e6faa0d8cba686deeb035c0fcd1b623722cdd87e0e1edf0c016d8b3df771a91e1d54f8485d361f1cce0686491b4301eaaab760b47d3c4e8d60004ee45058084683011acde7f683bac6b0d9edb17c916bbf7c2cf9e815fad8773a6c0c5d383bd06e2da784842e462a4f4e8df4bda186d032dedb6d81c0f8eb61d919dddc137fd47766a319fe4968ab1b078062c990995e37ca7915c90705c38a5d23d3a9a36465d006c302b2aefa413d0f11b32624343f0c46e58be1536b4fa4e23925ecec1dc49b074269cd70031ad1c94d4f4d45652ed9c1b1c4d23a1bcfd7677d81d0eae0aa32dc90f3d8760f916b86f53b04b9f48be99540a97ccd25a0149c96feaaadc75a36d249402a0a5c3de6ff0ad30da92dcf65c3bfcf1f9603bde848ed315a1280e174e872be7040b084586e578775da5bb6df4cd846077a73538634758ed496e3183a75be0f71b82237645e4d8e654c3d5a7046712e8c3548ec386a0a1a1caed1e6d43a1bdc75adaed19739c1e567b92fd0e0dc0caad70d746e83ce03b8d48f6985a069735c2c21950a8a707e4a59ea8ab72e785d150188f0102608e3b410580049bf4fceff3b07c331c1ad5121591fcb4b3077ef038fce64ff0ca9360e9ece0086311b3f04ee10d6d046057a75d10331e09ab3dc93e5d07e10fcf078ff2f50ff94e23923bc617c3b246b8628e8e2ace770ee6d756b9c7436a2b1c66166fe9a405a80eab4dc90eed07e08f2f04dff807b4698f48da8c29804533e1eab95056e23b8d78d05a5b49bd732e944fda50d79934b7dbf7715c1f669b125d6d07e037eb838d7bb45b9f48e69414c0a58d70f5c950aa4708f3c9ad7555ee7d6135166e01d069afc0f8df30db94e87971a8fffecdc1b6bd22e2474941b058f09a5360aca606729ec1b2fa2a775f58ed855a009859614b277b009d879583f6f5051dff3d1b35c72f1225e38a83d180cbe704fb0a484eeaacad64f26877ff3b5ae88f9a3677d8edc05bc26e57fc393800773e07776f843eadea1789acf212b8665eb0c360811e1fcc290e7e505be5de15729be16aeeb0d700bf09bb5dc9bca104acd806ffb31ef61ef69d46449235793cbcee345830d57712098b4bf0aada1a7757a86d86d9184053938d898f610f303eecb6257336b4c24fd642d35edf494424558d95f0a6b3a0b1ca771219a59e03dd4c6e6c74a19e9c9296dd26350d90bdb675c37faf85e7da7c271191303860fe5478c3e950ad335bb3523a86ff8fb41bbe962ebbd212843a5421e9b5f730fc7c1dacda0a3aa34724f714c6e0aab9c159035a28985dc25efdffa2b414006656d0d2c92e60523ada97f0bc38cfff8b75b05fc7f28ae4bc8ab1f0bad361e174df492449adb5954c71ce85feec555ad6893ae7060d7e958eb6253ccfb7c33fde13ec39aece5f243f741d84efae86cf3d00bbb5c627fa8c9fa5a3f387349e38b9bbd32e74c6c3e96a5f52d7732858e0b77aa7ef2422e2533c0e57ce816be7e9b0a1a872b0a0b6ca3d96a6b6d3c3cc5c4b279b8059e9ba878c8c010f6d0f3aff03fac62f2247948f81779c03e74cf19d445ee685ba2a7772ba1a4fdb5611ce39037e98aef66564f6ec83cf2d0f86fed4f98bc8d1ba0fc1cd0fc1371e815e7d3e4486336e4b6bfbe96c7c57a74d8919db01ad39f56430119cd4f7abf5dab75f448637b608de7046b09b605a3b08194e7f6c9086c9935dda1eca4efb7fdfe60ebb075896eefbc85fdad80eb73d0ecdbdbe938848b6993709fee63c98a4bd037cf9655d957b7d3a6f90f6026077bbbdd139fe3bddf7913f1b4804dbf7def53c24f450bf88a4a8280ed79d0aaf3a199c860332ca1c97d757ba7bd3798fb4ff273db23570335096ee7b096cee84efadd1b77e1109cf9c6a78ef028d0664d0f6da4a6639e7d23a719bf6f3a21a1adc21073f49f77df2dd60027efd27f8ec7deafc45245c1bdbe11fef86e55bb4536886fc47ba3b7fc8d01a8fe60e3b05d890a9fbe59b1ddd70eb6a1ddc2322e977461d5c3f3f387a58d262c81c33ea2b5d53ba6f94b10eb9b9d356602ccad4fdf28101f7bc003f7d462bfc452473c617c3bbe7c3d9f5be93e41e0777d456b96b3271afb44f01bcc812dc9aa97be583de3ef8ca0ab87dad3a7f11c9ac7d7df0d555c1c8637f5a36a9cd5f09e3fb99ba57c646003698159577b2131d10346aeb5be17baba1fbb0ef242292efea26c0072f80a9e5be93e484d6da4a1a9c738399b859c64600e639d70ffc47a6ee978b0613f0e3a7e08b0faaf317916868ee854fdf0bf76ef29d2427dc96a9ce1f32bc286fcf1e9b3414673ba0e52323d47920d8a67373a7ef242222c7764e7df0b8e0d822df49b2525fa131a3badab564ea86191b01009834c9ed31f85926ef990bd636c3a7ee56e72f22d1f6e46ef8a77b6167b7ef2459c8b83d939d3f78782cafb5cb4e4d2458e7e3ded9662801bf7b167eb3014c0fdf8a4896288c05e7095c7192ef2459c39ce3d4da4af76c266feaa5136eeeb03f0257f8b877b6e8ed836f3d021bf6f84e2222929a8ba7c33bcf85e202df49a2cde0cefa2a7775a6efeba500d8dd69cb9c718f8f7b67838dedf0b58761af16fa8948969b5a061fbe18aab58df07139e392da6af760c6ef9be91bbea8b9c39e02cef275ffa85abe057ef4140ce9d95a11c911a5c5f0b717c0bcc9be9344d2937555ee5c1f37cee822c097b9d9e3bd236728013f7b067ef0b83a7f11c92dfbfbe00b2be0cee77c27891e33bee2ebdede4600ccacb0a5932d4083af0c51b1af0fbef1303cdbe63b8988487a5d382d384ba028ee3b4924ecaaad64a6736ec0c7cdbd8d0038e7060cbee9ebfe51b1a31bfef11e75fe22921f1ed9019f5baecdcc00707cd557e71fdcdea3ce4e9bd067ec0426facce1cbba9660739f43defef38b88f85136063eb608a6e5ef16c2bd2531a65654386fe7b8fa5c034065a5ebc5f2737be0e55be02babd4f98b487eea3904ff727fb0d1593e72f01d9f9dff910c7eb5b458b515b215c88b87441206ffb516eedee83b8988887f31076f3d1b9635fa4e9251fb6383cc9a3cd9799dfcf53a0200505bebda1d7cdb778e4c383c0837af52e72f22f2a284c18f9e84db9fcaab1d4f6ff1ddf9430446000076f55a65ac9fadc004df59d2a5e7307c6945b0e84f4444fed27953e0fd17065b09e7b0bd4385cc6c98e8ba7c0789c41ff39409ae13f8baef1ce9d2be3f98eb52e72f22727c8fef822f3e000773786d94737c250a9d3f44640400a0abcb261e4eb00dc8a935a14d7be10b0f060b5e444464780d13e1e34ba07c8cef24a1eb2c76ccacac74bdbe8340444600002a2adc5ee7726b77c0e7dae05fee53e72f2232124d7be1b3f7c39e7dbe9384cbe04b51e9fc21422300006d6d563a18630b50e33bcb683db91bbef9300c247c271111c94e134be0638b617a6e8c0bb71724985953e3f6fb0ef2a2c88c0000d4d4b8fd86bf7d91c3b2622b7ced2175fe2222a3b1f730fcdb7278a1dd77921038fe3d4a9d3f446c0400a0b5d5c6250ad8024cf29d2515f76f861f3e99578fb38888a455511c6e5a08a766ef69822d438798d5d0e02235211ca9110080c993dd011c9ff79d23157f781e7ef8843a7f119130f50fc197570653abd9c8c1bf46adf387081600007dbddc0a6cf79d6324ee7c0e7efa34a8ef171109df6002befe48f0a86096d9b2bf3b9a5bde47b2009831c31d768e8ffbce91acfff913fcec19df29444472dbd0507074fa43db7d27499ec1471a1b5d9fef1cc712b93500476beeb00781c5be739cc84f9f0e86fe45442433620edebb002e9aee3bc989192cafaf7297face713c911c01785122c18dc090ef1cc7f3cbf5eafc4544322d61f0dd35f0c80edf494e68281ee346df214e24d205c0941af734c67fface712cbffe13fc6e83ef142222f9296170eb6a5813d122c0e0bb932bdc7adf394e24d2530000adad569328602330d1779617ddf502fcf75adf294444a420067f77119c5def3bc94b7453c49cba09aec377901389f40800c0e4c9aecd19ffea3bc78bfea8ce5f4424320613f0b547606d8bef242ff199a877fe90052300001bcc8aca3b590fccf199e3de4dc1b9d52222122d4571f8e86298eb7f23f9e76b2b39dd3917f9330d233f020030cfb97e333ee633c3a33be1c74ff94c202222c7d33f0437af84ad9e0fda75316eca86ce1fb2a40000a8af76bf07eef671ef3fb5c277576b873f1191283b34085f5a01cdbecedb73fca1b6c2fdafa7bb8f58d6140000cef11120a395d5a60eb8f9a1609e494444a26d5f1f7cfe41e83890f15bf75b828f64fcaea3905505406da5db007c2953f76bea812faf82bec14cdd51444446abeb207cee41e8cde0fe7b667caebedabd90b93b8e5e5615000007baf92cf05cbaefd37600bef8201c88e4068e222272227bf6c1575766ec0bdc0bfdfbb3ef10bbac2b001a1b5d1f096e208de7ee1ce8832f3d08dd87d37507111149b7cd9dc1d90143e99dc24d10e3fa19335cd6f51859570000d4d5b89538be978eb687868213a75af6a5a3751111c9a4a75b8263dad3c5c1b7eb2adc43e9bb43fa64650100500c1f07423d18d280ef3f0e1bf684d9aa8888f8f4c0d66007d7b039682e8ef18fe1b79c19595b005456bade98f1be30dbfce5baec3a6652444492f3d3b5e11f1e9480f75754b8bde1b69a39595b00004cae767702ff13465b2bb6c2ef9f0da3251111891a03bebf2678b43b0ccef1b3fa2af7bb705af323ab0b008082041f04ba47d3c6863df09f699c23121111ff061270f32a68df3feaa6ba6283d13eea3719595f00d4d4b8568c4fa47a7dfb01f8e623dae84744241ff4f6c19756c2a1516c29e7e0a649935cd6af16cbfa0200a0b68adb0c968ff4ba4383c173a2fbf4acbf8848de68ee855bd7a4bcbdfbbd932bf971c891bcc88902c03967e6783b90f4311066f09d47a1296b976f888848aa9edc05bfde30e2cbba8971bd732e274e86c9890200604aa5db85e33dc9befe97ebe1a9dde94c24222251f6db3fc19a113c19e01c37d455b89de94b945939530000d455baff017e34dcebd6ec803bb4e25f4424af19f0bdc7616732cbc88ddb6a2bdd2fd29d299372aa0080ff7b2a60d3f1fe79d3dee03f784e8cdf8888c8a8f40dc2571f82fd275e0bb6a5106eca50a48cc9b902a0a6c6ed77f0668e716cf0e1c1605f689dee2722222fea3800df5d7ddc45818331787375b5cbb90de273ae0000a8ad728f3bc7bfbdfcf7bfff58b0fa534444e4686b5be08e639f33fbff2657b935198e9311395900004caee05f80152ffefd1f5f803539b374434444c2f6cbf5b0bef5a8df70acaaade48bde02a559ce1600ceb944ac807702bd9b3ae0a7eb7c27121191287bf1f1f0ee4300f410e3adceb921cfb1d226670b0080c9656e5bdf001ffaf6a3c131bf22222227d2db07df7a04cc785f5db90bf9f8a068c9e902006046adfbe119b5acf59d434444b243dd049ea8af763ff39d23dd72be000058328f8b4eada5c7770e111189b6b9d5f45e5dc712df3932212f0a800b1bdca1f3a7b3b86a2c3af24744448ea9622c898b6771c91967b803beb364425e1400006f3ac7ad5b3c9b0f15e4cdbfb1888824ab200697cde6c6379ceb9ef29d2553f2aa3bfcc022f7cd2533b8cb770e111189964533f8dd0d8bdc377ce7c824e73b40a69999bbf1d7ec58df4283ef2c2222e2df69b5ecbae53aa6e6ca297fc9caab1100088e0ebea881f9532772e29d9f454424e74d9940df450d9c976f9d3fe4610100f0faf9ae75c94cae195fac33814444f2d58412ecf2d9bceaf5f35debf0afce3d79590000bce32277cf5527f3cff1b8ef2422229269f1182c6be4b36fb9d0ddef3b8b2f79b706e0e5be78af2dffe30b5ce23b87888864ce2b4fe6de8f5ee62ef79dc3a7bc2f00cc2cfe89dfb1f9895d4cf79d454444d26fc11476fcfbab9995cbfbfc27236fa7005ee49c1bba602267cdaa4007058b88e4b85915ec9b3f8d33f3bdf3071500005c7b89ebb97216e7d58d67c077161111498fc9a50c2c6ae4bc6bcf72da1a1e1500ffe7ba056ee3c2e95c35be444f068888e49ad222ece2995cfbd6f3dc0bbeb344850a80a3bc77b1bbe7d259bcaf484f068888e48ca2382c9dcd8def5fe4fee03b4b94a8007899bfbbc47d77e96cbee3f27e79a48848f6730e2e9dcd376f5ceabeee3b4bd4a89b3b8ecfdc65f7afdcca52df39444424758b6672cf675ee9aef09d238a54001c8799b97fb8833faddec95cdf59444464e4ce6b60d3e7afe1a47cdce637199a02380ee79c2d3b8d73cead678fef2c2222323267d4b1e715a773ba3affe35301700297cc70872f3f997927d7b0d77716111149ce2935f45c7112732f99e10efbce12652a008671d929ae73c9744e9e5ece01df594444e4c4a69571f0e2e99cfe8a79aecb7796a853019084d7cf77ad97cce0ccfa093a42584424aa268fa77f513de7bc71be6bf29d251ba80048d25b2f749bcf6ae0e2aa71da2d5044246aaa4b195c388385efbcc43def3b4bb650013002375de29eb8743a4b2bc792f77b488b884445c5588696cce08af72d728ff9ce924df418600abefb905d72ef46eeed3a88f60c1411f1a87c0c89cb4fe6caf75ee4eef19d25db68042005efbdd83d70d94cae2d2b21e13b8b8848be1a5f8c2d9bc95fabf34f8d460046e13f1eb5d7dfb1819ff51ed69fa38848268d2fc1ae3a8977bc7ba1fbb1ef2cd94a2300a3f0ae0bdc2fae98c37b4b8b7582a08848a68c2fc1ae3e89ebd5f98f8ebeb986e0bbabec7577bfc0cf7a0eaba0121149a7f125d82b66f3f6f72d71b7fbce92ed540084e49b0fdab5cb37f32b15012222e931b184c4158dbce986c5eee7beb3e402150021fae64abb74c566eeeed4d3012222a12a1fcbd0a5b379f5fb17b93ff8ce922b540084ece6e576d1a33b78a0e30085beb38888e4828a310c2e9cc5e51f5ae21ef09d2597a8004883af3f60e73fba93157bf651e43b8b884836ab29a5fffce95c7ce312f7b8ef2cb94605409adcfe909db47c3b4fede861acef2c2222d9a8a18c43e736b0e06f17bbf5beb3e422150069f4a347acfed126366c6c67a2ef2c2222d9647615fbe6cfe1b4ebcf763b7c67c9552a00d26ce55356fd3fdbd8b0be856adf594444b2c1bc49b45f3e83b9579feb3a7c67c9652a0032e0174d36e6b12779faa95dccf19d454424cace9bc2e6d74de18c73cf75077d67c9752a0032c4ccdca7ee60f9633b59a26d0345445eca018b66f2e8ffbb928b9c73fa98cc006d5a9321ce39fbdc35ee92cb1bf976a1fed44544fe4f410c2e9bcd0f3efd4a77a13affccd10880075f596e7fb76233b7ec81a1091200000ac249444154efd79fbf88e4b7b1c5d8d2597ce2a6a5ee4bbeb3e41b75409e7ce341bbf2e1edfcae6dbf360c1291fc543996c10ba7f2ba0f5fe67eeb3b4b3e5201e0d17757d8698f36f1e8ce1ec6f9ce22229249d3ca39705e0317be7f915be73b4bbe5201e0d98fd658e5dadd3cbdae9929beb3888864c29975349f3f9d335f7fb66bf79d259fa9008800338b7fe53eeebe7b13970e257ca71111498f9883853358f9ffae64a9736ec8779e7ca7f5e811e09c1bfae83277d92be7f0b971456805ac88e49c9242ecf293f8e2a75fe916abf38f068d0044ccd757d8e58f6ee7f77bf651ec3b8b884818aa4be9bf683aaffdbb25ee0edf59e4cf540044d0d71fb0297fdac3e39b3b98ec3b8b88c8689c5c4debbcc9ccffc062d7e43b8bbc940a8088fa8c598cbbf8edc33bb85aeb024424dbc41ccc6fe0e165e35972c9256ed0771ef94b2a0022eee607eca3ab36f3859e3eadd71091ec30a198c405d3f8d4272e775ff09d458e4f054016f8cfc7ecccd55b58b1a99309beb388889cc8cc0af62f98cab2775fec56fbce2227a602204bfcee211bff58178faedec93c3d26202251e38005d35877662917bdfe12b7df771e199e0a802c73cb03f62f2bb7f0a99ec39a12109168185f8c2d9ec1576fbacc7dd47716499e0a802cf4a3c7edac47b772dfc6762a7c671191fc36bb8abd0b2673e5bb96b8477d679191510190a57e61165f7f27bf5cddc4b57a4a4044322d1e8373ea59f1da7a969d7bae1bf09d47464e054096fbf2fdf6d6c79bb8ad7d3f45beb388487e98348e810ba6f39ebfbbc4fdd07716499d0a801cf0ef7759f5ff6fefde9fa2bcee30803f67afec725d963b8880309528a2a2a8418d444d52632769a6b54dd3a835e9d814d3ea3469d3994e3ad699346d63ad8936346947c7da4b9ca6d3196d9236a8a508ea48102f046d5484456059605d58581676f7f407679ad6b6891a96b397e7f3173c3fecfbee33e7f27d7b4771f85c174a7840908882450028cbc6c5996958bab642f4aace439f0c0b4004f9698ddc5adf8eef393d3c204844132b2906814579d8feec0af16dd5596862b00044983fbe278b4f75e2dd933664abce42449161663aec7333b17cfd62d1a23a0b4d1c168008b5bd46be507f15dfe1754122ba53f146c86505a8de7c2faa8410dc618c302c00116c77ad2cbee8c0a1f33d28509d8588c24b69163aa76760d5c6bbc539d55928385800a2c0cec3f2b9061bb639dcd0a9ce4244a1cd1a0b7ff914bcf0ec0af1bcea2c145c2c0051e2b72764fad95efcb9d186b20017f288e8265a0d302713e7a75971dfc6a5a25b751e0a3e168028b3b356ae6bb2e155db7598546721a2d0909d006ff9146c7eba5254abce42938705200a1d6890a616270e347662b587f3bb88a296490f54e4a126077878edfd6258751e9a5c2c0051ec7727e592c66bf87d7317b2b82b40143d04805999b8563e056b1e2d170daaf3901a2c00845db5b2ea940d3fe1b60051e4cb4e8077612e9eaf5a267eac3a0ba9c50240006e6c0b9ceec39e73dd583332cedf0551a4311b20cb7370707a09beb8668af0a8ce43eaf1454fff61479d2cb03b71a0a913653e7e659028ec6935c0ac0c7c90138f87b6ac14adaaf350e86001a0ff69778d7ce082137bdeb72383e70388c2d3a752d13f230beb372d11875467a1d0c302401f69f751f94c5317b6b53911a33a0b11dd9adc4478e7e7e28755f788adaab350e86201a08fd5d0204df52378b5f11a1e730c719a2051a84a8d876f7e167e7dd70a3cb54a08afea3c14da5800e896fda2519a1d7dd875a61b6bfb87a1559d87886eb09810989b8d3fcd8cc3fa87168b21d579283cb000d06d3b54272d4d6e549feec4e75c5e7e6d90489538036469160e17a7e0cb5f5a28ecaaf350786101a03bf6b31a99dee3c6be965eac1c1ee36f8968b2c41a21e766a22e37098f3eb15874a9ce43e1892f6dfac45eaf91e9d7bc78fd6c0f1ebceee18a0051b0c4c740ce48434396158f6daa10edaaf350786301a00973b859663739f0ab931d5839c022403461926fecf11fb92b1b1b1e2e1136d5792832b000d0843bd828539a1dd87dbe1b8f3846786b80e84ea5c6c3579689b74bd3f1e4fda5a257751e8a2c2c001434478f4a5dfd18bedfe1c4d397fa90a83a0f51b8c849c048612af62f998e6f56e68b51d5792832b100d0a478b9566e68ebc7d6f33dc8f173c430d17f1102989e8a81e20cbc58b5042f0921388493828a058026d52b87e5bded83d8deda8b520f3f3a4404931e28c9446b91159b9fa8107f559d87a2075fc0a4c4d15699d7dc8d9dcdd7f0699b0b7ad57988265b7a3c7c33527164461abefed979e2b2ea3c147d5800482929a5a6ba0e1baff4e399733d2818f3ab4e44143c5a2d509c06fb340b5efb4625b60921c65567a2e8c5024021e3e523b2d4eec68b9707b0bcd7cd55018a1ce971f015a7e158be05df7a7c9168529d87086001a010f4efab022d76148cfa542722ba7d062d509482ee422b7e39ab123fa81482bf640a292c0014d2de3c250b2e0ee0476d0378f04a3f4c3c164da14c00c84f86a73019070b2c786ecd02d1a63a13d1ffc3024061637f835cdeeec2772ff56369fb756e1150e8c84c80bfc88ae6022b5e7a7c01dee0153e0a072c001476a494dabd27b0a1630055177a51621fe6d8619a7cc966040a9371616a32767d6d095e1342f0082b851516000a6b47db64ccd92bf86a971bebaf3a51ea7043ab3a1345aeb458040a53d09a9d843d2b32b0aba84878556722ba532c001431a494fabd27b0becb8527db9d9873b91f7aaec3d2279591005f9e05e75362b16f4b255e113ccc47118205802256759d7ca0cb854d3d6e54b43991e4e7022ddd029d06c8b762382701278b5251fd8532bc2984e0006b8a382c001415de69918557fb50651bc467fee1407eff08cf0dd08752cc08e459d0911a8bbf4cb560c79af9e2a2ea4c44c1c6024051474aa9dd558b47fa86b1d6eec6c28eeb4819e53cb6a812a307f22d7065c4e3bd5c0b7e336f01f6cf10624c752ea2c9c4024051afc526938fb563ddc03056dbdd98fd411f923d2c0411c5a005722d70a5c6a2c56ac0db73aca8ae9c27fa54e72252890580e826ef34c8e4f747b1ceedc5aabe21ccb60dc2ea1ae5b3124e124d903909e84b35e34ca21987a659b16ff52ce1549d8b2894f0a546f431a494dabdc7b1d23e84cf3b3d58647723bf7b1031e33c161612f41a202b119e3433ae5a63519f92883f7ca51c35bc974ff4d1580088ee40dd5969691dc2eade2154bac7306b6814f936172c6e2f9fa96032e9808c448ca49ad16136e06cbc01c7cba6e18da579a25b7536a270c39715d104794b4a63c731dce7f2e29e612fe60e7a30cde9415aef3062bcbc397e5b6274405a1c469362d01b6fc2a5383d4e2798f0b7a98bf1ee2ac1e13b441381058028c8de92d2d8731ccb1c6e5478c65132328e02b717992e2f12fb8761188bd2856a8316b09a319668822bde882e931e57cc3a9c4b8c45fd94bb51cb3f7aa2e062012052484aa9ff7903660f8f60deb80f33bc01e48d8e21c7eb47ca901709ee7198063dd0855b4930688104137c717a78128c18d4ebe030ebd1a917b81a63448bd980534f2dc6194ed52352870580280cecf8bbcc3468307ddc8b426f00d93e3fd2477d481b0f20d9e7435240c2ec0dc0ec0f20c61f80d63b0ee3b884d6ef87c62fa1f5fa3f7cd60312e2e6b907663d00817f4d4e366a20b51af8751a04741af88d7a78b51af8b51a8c1a3518110223061dae1bb5e8d709388c7af46875e834ea71652c800b5b96724f9e8888888888888888888888888888888888888888888888888888888888888888e856fd134b6fd6ce2df2ca400000000049454e44ae426082)', 
        [full_name_sign_up, email_sign_up, username_sign_up, password_sign_u], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        })
    })
};

//AJAX (mengecek apakah username yg diinput user sudah ada di database)
app.get('/check_username', (req, res) => {
    const inputed_username = req.query.inputed_username;
    let usernameTaken = true;
    usernameChecker(inputed_username).then((data) => {
        usernameTaken = (JSON.parse(JSON.stringify(data))[0]) !==undefined;
        const response = {
            taken: usernameTaken
          };
          
          res.json(response);
    });
})
//cek ke database
const usernameChecker = (username_sign_up) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT idUser FROM user WHERE username = ?', [username_sign_up], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//AJAX (mengecek apakah email yg diinput user sudah ada di database)
app.get('/check_email', (req, res) => {
    const inputed_email = req.query.inputed_email;
    let emailTaken = true;
    emailChecker(inputed_email).then((data) => {
        emailTaken = (JSON.parse(JSON.stringify(data))[0]) !==undefined;
        const response = {
            taken: emailTaken
          };
          
          res.json(response);
    });
})
//cek ke database
const emailChecker = (email_sign_up) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT idUser FROM user WHERE email = ?', [email_sign_up], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//membuka halaman verify email
app.get('/verify_email', (req, res)=>{
    res.render('verify_email',{
        email: email_sign_up
    }) 
})
//membuka halaman konfirmasi verify email
app.get('/verify_conf', (req, res)=>{
    res.render('verify_conf',{
        email: email_sign_up
    }) 
})
//==============================================================================================================


//PUBLIC DASHBOARD----------------------------------------------------------------------------------------------
app.get('/dashboard_public',auth, (req, res)=>{
    getDashboardData().then((dashboardData) => {
        res.render('dashboard_public',{
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            dashboardData: dashboardData,
            status : req.session.status
        }) 
    })
})

const getDashboardData = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT bag.bag_name, bag.bag_photo, bag.idBag, review_count.banyak_review, review_avg.nilai_review FROM bag JOIN ((SELECT COUNT(idReview) AS banyak_review, idBag FROM review GROUP BY idBag) AS review_count) ON bag.idBag = review_count.idBag JOIN ((SELECT AVG(value) AS nilai_review, idBag FROM review GROUP BY idBag) AS review_avg) ON bag.idBag = review_avg.idBag ORDER BY review_avg.nilai_review DESC LIMIT 10', (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};


// Add a new route for sorting
app.get('/sortData',auth, (req, res) => {
    const sortOption = req.query.sort;
    let sqlQuery = '';
  
    // Determine the SQL query based on the sortOption
    if (sortOption === 'review-nilai') {
      sqlQuery = 'SELECT bag.bag_name, bag.bag_photo, bag.idBag, COALESCE(count.banyak_review, 0) AS banyak_review, COALESCE(avg.nilai_review, 0) AS nilai_review FROM bag LEFT JOIN (SELECT COUNT(idReview) AS banyak_review, idBag FROM review GROUP BY idBag) AS count ON bag.idBag = count.idBag LEFT JOIN (SELECT AVG(value) AS nilai_review, idBag FROM review GROUP BY idBag) AS avg ON bag.idBag = avg.idBag ORDER BY avg.nilai_review DESC LIMIT 10';
    } else if (sortOption === 'review-banyak') {
      sqlQuery = 'SELECT bag.bag_name, bag.bag_photo, bag.idBag, COALESCE(count.banyak_review, 0) AS banyak_review, COALESCE(avg.nilai_review, 0) AS nilai_review FROM bag LEFT JOIN (SELECT COUNT(idReview) AS banyak_review, idBag FROM review GROUP BY idBag) AS count ON bag.idBag = count.idBag LEFT JOIN (SELECT AVG(value) AS nilai_review, idBag FROM review GROUP BY idBag) AS avg ON bag.idBag = avg.idBag ORDER BY COALESCE(count.banyak_review, 0) DESC LIMIT 10';
    }
  
    // Execute the SQL query and retrieve sorted data
    pool.query(sqlQuery, (err, result) => {
    if (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    } else {
      const sortedData = result;
  
      // Render the sorted data using the same EJS template
      res.render('bag_items', { 
        dashboardData: sortedData
     }, (err, html) => {
        if (err) {
          console.error(err);
          res.status(500).send('Internal Server Error');
        } else {
          res.send(html);
        }
      });
    }
  });
  
  });
//==============================================================================================================

//BAG REVIEW----------------------------------------------------------------------------------------------
app.get('/bag_details/:id',auth, async (req, res) => {
    try {
        //mengambil id dari bag yg ingin dilihat detailnya
        const idBag = parseInt(req.params.id); // Convert userId to an integer

        if (isNaN(idBag)) {
            res.status(500).send('Invalid userId'); // Send an error message to the client
            return; // Stop further code execution
        }

        const bagDetails = await getBagDetails(idBag);
        const res_bagDetails = JSON.parse(JSON.stringify(bagDetails))[0];

        const bagReviews = await getBagReviews(idBag);
         
        const bagReviewCount = await getBagReviewsCount(idBag);
        const bagReviewAvg = await getBagReviewsAvg(idBag);
        const bagReviewsValue = await getBagReviewsValue(idBag);

        res.render('bag_review', {
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            res_bagDetails: res_bagDetails,
            bagReviews: bagReviews,
            bagReviewCount: (JSON.parse(JSON.stringify(bagReviewCount))[0]).jumlah,
            bagReviewAvg: (JSON.parse(JSON.stringify(bagReviewAvg))[0]).avg,
            bagReviewsValue: bagReviewsValue,
            status : req.session.status
        })
    } catch (error) {
        console.error(error);
        res.status(500).send('An error occurred');
    }
});

const getBagDetails = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT * FROM bag JOIN sub_category ON Bag.idSubCat = sub_category.idSubCat JOIN category ON sub_category.idCat = category.idCat JOIN brand ON brand.idBrand = bag.idBrand JOIN designer ON designer.idDes = bag.idDes WHERE bag.idBag = ?', [id], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

const getBagReviews = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT * FROM bag LEFT JOIN review ON bag.idBag = review.idBag JOIN user ON review.idUser = user.idUser WHERE bag.idBag = ?', [id], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

const getBagReviewsValue = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT value FROM review WHERE idBag = ?', [id], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

const getBagReviewsCount = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COALESCE(COUNT(idReview), 0) AS "jumlah" FROM review WHERE idBag = ?', [id], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

const getBagReviewsAvg = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COALESCE(AVG(value), 0) AS "avg" FROM review WHERE idBag = ?', [id], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

//==============================================================================================================

//ADD REVIEW----------------------------------------------------------------------------------------------
app.get('/add_review/:id',auth, async (req, res) => {
    try {
        //mengambil id dari bag yg ingin dilihat detailnya
        const idBag = parseInt(req.params.id); // Convert userId to an integer

        if (isNaN(idBag)) {
            res.status(500).send('Invalid userId'); // Send an error message to the client
            return; // Stop further code execution
        }

        const bagDetails = await getBagDetails(idBag);
        const res_bagDetails = JSON.parse(JSON.stringify(bagDetails))[0];
        const bagReviewCount = await getBagReviewsCount(idBag);
        const bagReviewAvg = await getBagReviewsAvg(idBag);
        const reviewDesc = await getReviewDetails();

        res.render('add_review', {
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            res_bagDetails: res_bagDetails,
            bagReviewCount: (JSON.parse(JSON.stringify(bagReviewCount))[0]).jumlah,
            bagReviewAvg: (JSON.parse(JSON.stringify(bagReviewAvg))[0]).avg,
            reviewDesc: reviewDesc
        })
    } catch (error) {
        console.error(error);
        res.status(500).send('An error occurred');
    }
});

const getReviewDetails = () => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT * FROM review_value', (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

app.post('/add_review/:idBagtoReview',auth, (req, res)=>{
    const idBagtoReview = parseInt(req.params.idBagtoReview);
    const rating = req.body.nilai_review;
    const review = req.body.input_review;
    const idUser = req.session.idUser;

    
    addReview(idBagtoReview, rating, review, idUser).then(() => 
        res.redirect('/review_added_conf')
    )
})

const addReview = (idBag, rating, review, idUser) => {
    return new Promise((resolve, reject) => {
        pool.query('INSERT INTO Review (idBag, value, review_text, idUser) VALUES (?, ?,?,?)',[idBag, rating, review, idUser], (err, result) => {
            if (err) {
                reject(err);
            } else {
                resolve(result);
            }
        });
    });
};

app.get('/review_added_conf',auth, (req, res)=>{
    res.render('review_added_conf',{
        username: req.session.username,
        photo: Buffer.from(req.session.photo).toString('base64')
    }) 
})

//==============================================================================================================

//SEARCH FOR USER&BAG----------------------------------------------------------------------------------------------
app.get('/search', auth, async (req, res) => {
    try {
      const search_input = req.query.search_input;
      const userId = req.session.idUser;
  
      const users = await searchUsers(search_input, userId);
      const bags = await searchBags(search_input);
      const following = await followingList(userId);
      const followers = await followersList(userId);
  
      res.render('search', {
        username: req.session.username,
        photo: Buffer.from(req.session.photo).toString('base64'),
        followingList: following,
        followersList: followers,
        searchResultsUsers: users,
        searchResultsBags: bags,
        status : req.session.status
      });
    } catch (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    }
  });
  
  
  //method to search users (cannot search admin and their own account)
  const searchUsers = (search_input, userId) => {
    return new Promise((resolve, reject) => {
      const query = `
        SELECT User.*, 
          CASE WHEN EXISTS (SELECT 1 FROM Follow WHERE idU1 = ? AND idU2 = User.idUser) THEN 1 ELSE 0 END AS isFollowed 
        FROM User 
        WHERE username LIKE ? AND status = 1 AND User.idUser <> ?`;
      const params = [userId, `%${search_input}%`, userId];
  
      pool.query(query, params, (err, result) => {
        if (err) {
          reject(err);
        } else {
          const usersWithFollowStatus = result.map((user) => {
            user.isFollowed = user.isFollowed === 1; // Convert 1/0 to true/false
            return user;
          });
          resolve(usersWithFollowStatus);
        }
      });
    });
  };

  //method to search for bags
  const searchBags = (search_input) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT bag.bag_name, bag.bag_photo, bag.idBag, IFNULL(review_count.banyak_review, 0) AS banyak_review, IFNULL(review_avg.nilai_review, 0) AS nilai_review FROM bag LEFT JOIN (SELECT COUNT(idReview) AS banyak_review, idBag FROM review GROUP BY idBag) AS review_count ON bag.idBag = review_count.idBag LEFT JOIN (SELECT AVG(value) AS nilai_review, idBag FROM review GROUP BY idBag) AS review_avg ON bag.idBag = review_avg.idBag WHERE bag.bag_name LIKE ?', ['%' + search_input + '%'], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
  
  
//==============================================================================================================

//PROFILE PUBLIC----------------------------------------------------------------------------------------------
//membuka halaman profile public, mengambil data" yang akan ditampilkan dari database
app.get('/profile_public', auth, async (req, res) => {
  try {
    let startData = req.query.start;
    const followingCountResult = await followingCount(req.session.idUser);
    const followersCountResult = await followersCount(req.session.idUser);
    const reviewUserCountResult = await reviewUserCount(req.session.idUser);

    const followingCountValue = JSON.parse(JSON.stringify(followingCountResult))[0].following;
    const followersCountValue = JSON.parse(JSON.stringify(followersCountResult))[0].followers;
    const userReviewCountValue = JSON.parse(JSON.stringify(reviewUserCountResult))[0].jumlah_user_review;

    let userDataReviewResult;

    if (startData === undefined) {
      startData = 0; // Set default value to 0
    }
    
    userDataReviewResult = await userReviewsLimit(req.session.idUser, startData);

    res.render('profile_public', {
      full_name: req.session.full_name,
      username: req.session.username,
      photo: Buffer.from(req.session.photo).toString('base64'),
      followers: followersCountValue,
      following: followingCountValue,
      user_review_count: userReviewCountValue,
      userDataReview: userDataReviewResult
    });
  } catch (error) {
    // Handle any errors that occur during the async operations
    console.error(error);
    res.status(500).send('Internal Server Error');
  }
});

  
  


//mencari tau brp banyak followers dari user melalui database
const followersCount = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COUNT(idU1) AS "followers" FROM follow WHERE idU2 = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
//mencari tau brp banyak following dari user melalui database
const followingCount = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COUNT(idU2) AS "following" FROM follow WHERE idU1 = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
//mencari tau user tsb sudah memberika berapa banyak review
const reviewUserCount = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COUNT(idUser) AS "jumlah_user_review" FROM review WHERE idUser = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
//mencari tau review" yang sudah dibuat oleh user
const userReviews = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT review.review_text AS "teks", review.value AS "nilai", bag.bag_name AS "namaTas", bag.bag_photo AS "fotoTas" FROM review JOIN bag ON review.idBag = bag.idBag WHERE idUser = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//mencari tau review" yang sudah dibuat oleh user
const userReviewsLimit = (id,start_data) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT review.review_text AS "teks", review.value AS "nilai", bag.bag_name AS "namaTas", bag.bag_photo AS "fotoTas" FROM review JOIN bag ON review.idBag = bag.idBag WHERE idUser = ? LIMIT ?,?', [id, parseInt(start_data), 4], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
//==============================================================================================================

//warning: kode bawah ini akan run dua kali --> menyebabkan pembacaan undefined pada iterasi kedua (sudah dihandle menggunakan isNaN(userId))
//OTHER PEOPLE PROFILE----------------------------------------------------------------------------------------------
app.get('/other_user/:userId', auth, async (req, res) => {
    try {
        const userId = parseInt(req.params.userId); // Convert userId to an integer

        if (isNaN(userId)) {
            res.status(500).send('Invalid userId'); // Send an error message to the client
            return; // Stop further code execution
        }

        const followingResult = await followingCount(userId);
        const following = followingResult[0].following;

        const followersResult = await followersCount(userId);
        const followers = followersResult[0].followers;

        const userReviewCountResult = await reviewUserCount(userId);
        const userReviewCount = userReviewCountResult[0].jumlah_user_review;

        const userDataReview = await userReviews(userId);
        const userDataReviewRes = userDataReview;

        const otherUserData = await getOtherUserData(userId);
        const res_otherUserData = JSON.parse(JSON.stringify(otherUserData))[0];

        res.render('other_user_profile', {
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            other_full_name: res_otherUserData.full_name,
            other_username: res_otherUserData.username,
            other_photo: res_otherUserData.user_photo,
            other_id :res_otherUserData.idUser,
            other_followers: followers,
            other_following: following,
            other_user_review_count: userReviewCount,
            other_userDataReview: userDataReviewRes,
            status : req.session.status
        });
    } catch (error) {
        console.error(error);
        res.status(500).send('An error occurred');
    }
});

  const getOtherUserData = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT * FROM user WHERE idUser = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};


//==============================================================================================================

//EDIT PROFILE----------------------------------------------------------------------------------------------
app.get('/edit_profile',auth, (req, res)=>{
    res.render('edit_profile',{
        username: req.session.username,
        photo: Buffer.from(req.session.photo).toString('base64'),
        full_name: req.session.full_name,
        email: req.session.email
    })  
})

app.post('/change_photo_public', upload.single('photo'), auth, (req, res) => {
    const newPhoto = req.file; // The uploaded photo is available as req.file
    const idUser = req.session.idUser;
    const photoData = fs.readFileSync(newPhoto.path);
    changePhoto(idUser,photoData).then(() => {
        getNewPhoto(idUser).then((newPhoto) => {
            req.session.photo = JSON.parse(JSON.stringify(newPhoto))[0].user_photo;
            

            res.redirect('/changed_conf_public');// Redirect the user to the profile page after saving changes
    })
    })
  })

//mencari tau review" yang sudah dibuat oleh user
const changePhoto = (id,photo) => {
    return new Promise((resolve, reject) => {
        pool.query('UPDATE user SET user_photo = ? WHERE idUser = ?', [photo, id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

const getNewPhoto = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT user_photo FROM user WHERE idUser = ?', [id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

app.get('/changed_conf_public',auth, (req, res)=>{
    res.render('changed_conf_public',{
        username: req.session.username,
        photo: Buffer.from(req.session.photo).toString('base64')
    })  
})


//==============================================================================================================

//FOLLOWING & FOLLOWERS LIST---------------------------------------------------------------------------------
//membuka halaman following (user" lain yg difollow user tsb)
app.get('/following_public',auth, (req, res)=>{
    followingList(req.session.idUser).then((followingList) => {
        res.render('following_public',{
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            followingList: followingList
        })  
    })
})



//mencari tau list user" yang difollow oleh user tsb
const followingList = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT User.*, CASE WHEN EXISTS (SELECT 1 FROM Follow WHERE idU1 = ? AND idU2 = User.idUser) THEN 1 ELSE 0 END AS isFollowed FROM User INNER JOIN Follow ON User.idUser = Follow.idU2 WHERE Follow.idU1 = ?', [id,id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

app.get('/followers_public',auth, (req, res)=>{
    followersList(req.session.idUser).then((followersList) => {
        res.render('followers_public',{
            username: req.session.username,
            photo: Buffer.from(req.session.photo).toString('base64'),
            followersList: followersList
        })  
    })
})



//mencari tau list user" yang difollow oleh user tsb
const followersList = (id) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT User.*, CASE WHEN EXISTS (SELECT 1 FROM Follow WHERE idU1 = ? AND idU2 = User.idUser) THEN 1 ELSE 0 END AS isFollowed FROM User INNER JOIN Follow ON User.idUser = Follow.idU1 WHERE Follow.idU2 = ?', [id,id], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

// Follow/unfollow a user
app.post('/follow/:userId', auth, (req, res) => {
    const userIdFollow = req.params.userId;
  
    checkFollowQuery(req.session.idUser, userIdFollow)
      .then((hasFollow) => {
        const followExists = hasFollow[0].count > 0;
  
        if (followExists) {
          return unfollowUser(req.session.idUser, userIdFollow);
        } else {
          return followUser(req.session.idUser, userIdFollow);
        }
      })
      .then(() => {
        res.json({ success: true });
      })
      .catch((error) => {
        console.error('Failed to follow/unfollow user:', error);
        res.status(500).json({ success: false, error: error.message });
      });
  });

//mencari tahu apakah user tsb sudah difollow (tampilan button followed)
const checkFollowQuery = (myId, userId) => {
    return new Promise((resolve, reject) => {
        pool.query('SELECT COUNT(*) AS count FROM Follow WHERE idU1 = ? AND idU2 = ?', [myId, userId], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//mengupdate data jika user mengfollow user lain
const followUser = (myId, userId) => {
    return new Promise((resolve, reject) => {
        pool.query('INSERT INTO Follow (idU1, idU2) VALUES (?, ?)', [myId, userId], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};

//mengupdate data jika user mengunfollow user lain
const unfollowUser = (myId, userId) => {
    return new Promise((resolve, reject) => {
        pool.query('DELETE FROM Follow WHERE idU1 = ? AND idU2 = ?', [myId, userId], (err, result) => {
            if(err){
                reject (err);
            }
            else{
                resolve(result);
            }
        }
        )
    })
};
  
//==============================================================================================================


//LOG OUT----------------------------------------------------------------------------------------------
//membuka halaman log out
app.get('/log_out', auth, (req, res) => {
    res.render('log_out')
})
//membuka halaman konfirmasi log out (session akan didestroy)
app.get('/log_out_conf', auth, (req, res) => {
    //menyimpan username sebelum session di destroy
    const username = req.session.username;

    // Destroy the session
    req.session.destroy((err) => {
        if (err) {
            console.log(err);
        } else {
            res.render('log_out_conf', {
                username: username
            });
        }
    });
})
//==============================================================================================================

//ADMIN-------------------------------------------------------------------------------------------


// agar bisa masuk ke halaman add item
app.get('/pick_add', (req, res) => {
    res.render('pick_add');
});

//ADD ITEM -------------------------------------------------------------------------------------------

// agar bisa masuk ke halaman add_category
app.get('/add_category', (req, res) => {
    res.render('add_category');
});

// agar bisa masuk ke add_sub_category
app.get('/add_sub_category', (req, res) => {
    getCategories()
        .then(categories => {
            res.render('add_sub_category', { categories });
        })
});

// agar bisa masuk ke add_brand
app.get('/add_brand', (req, res) => {
    res.render('add_brand');
});

// agar bisa masuk ke add_bag
app.get('/add_bag', (req, res) => {
    Promise.all([getBrands(), getDesigners(), getCategoriesBag(), getSubCategories()])
      .then(([brands, designers, categories, subCategories]) => {
        res.render('add_bag', { brands, designers, categories, subCategories });
      })
  });

// agar bisa masuk ke add_designer
app.get('/add_designer', (req, res) => {
    res.render('add_designer');
});

//==============================================================================================================

//ADD CATEGORY-------------------------------------------------------------------------------------------
// agar bisa ngambil data dari add_category
app.post('/add_category', (req, res) => {
  let added_category = req.body.category;
  addCategory(added_category)
    .then(() => {
      res.redirect('/item_added_conf');
    })
});

// mengecek kategori menggunakan AJAX
app.get('/check_category', (req, res) => {
  let category = req.query.inputed_category;
  let categoryTaken = true;
  checkCategoryExistence(category).then((exists) => {
      categoryTaken = (JSON.parse(JSON.stringify(exists))[0]) !==undefined;
        const response = {
            taken: categoryTaken
          };
      res.json( response );
    })
    
});

const checkCategoryExistence = (added_category) => {
  return new Promise((resolve, reject) => {
      pool.query('SELECT idCat FROM category WHERE cat_name = ?', [added_category], (err, result) => {
          if(err){
              reject (err);
          }
          else{
              resolve(result);
          }
      }
      )
  })
};


// meletakkan data dari input ke database kategori
const addCategory = (category) => {
    return new Promise((resolve, reject) => {
      pool.query('INSERT INTO category (cat_name) VALUES (?)', [category], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
  
//==============================================================================================================

//ITEM_ADDED_CONF-------------------------------------------------------------------------------------------

app.get('/item_added_conf', (req, res) => {
    res.render('item_added_conf');
});

//==============================================================================================================

//ADD BRAND-------------------------------------------------------------------------------------------

// agar bisa ngambil data dari add_brand
app.post('/add_brand', (req, res) => {
    let added_brand = req.body.brand;
    addBrand(added_brand)
        .then(() => {
            res.redirect('/item_added_conf');
        })
});

// meletakkan data dari input ke database brand
const addBrand = (brand) => {
    return new Promise((resolve, reject) => {
      pool.query('INSERT INTO brand (brand_name) VALUES (?)', [brand], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };

// mengecek kategori menggunakan AJAX
app.get('/check_brand', (req, res) => {
  let brand = req.query.inputed_brand;
  let brandTaken = true;
  checkBrandExistence(brand).then((exists) => {
      brandTaken = (JSON.parse(JSON.stringify(exists))[0]) !==undefined;
        const response = {
            taken: brandTaken
          };
      res.json( response );
    })
    
});

const checkBrandExistence = (added_brand) => {
  return new Promise((resolve, reject) => {
      pool.query('SELECT idBrand FROM brand WHERE brand_name = ?', [added_brand], (err, result) => {
          if(err){
              reject (err);
          }
          else{
              resolve(result);
          }
      }
      )
  })
};

  
//==============================================================================================================

//ADD DESIGNER-------------------------------------------------------------------------------------------

// agar bisa ngambil data dari add_designer
app.post('/add_designer', (req, res) => {
    let added_designer = req.body.designer;
    addDesigner(added_designer)
        .then(() => {
            res.redirect('/item_added_conf');
        })
});

// meletakkan data dari input ke database designer
const addDesigner = (designer) => {
    return new Promise((resolve, reject) => {
      pool.query('INSERT INTO designer (des_name) VALUES (?)', [designer], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };

// mengecek designer menggunakan AJAX
app.get('/check_designer', (req, res) => {
  let designer = req.query.inputed_designer;
  let designerTaken = true;
  checkDesignerExistence(designer).then((exists) => {
      designerTaken = (JSON.parse(JSON.stringify(exists))[0]) !==undefined;
        const response = {
            taken: designerTaken
          };
      res.json( response );
    })
    
});

const checkDesignerExistence = (added_designer) => {
  return new Promise((resolve, reject) => {
      pool.query('SELECT idDes FROM designer WHERE des_name = ?', [added_designer], (err, result) => {
          if(err){
              reject (err);
          }
          else{
              resolve(result);
          }
      }
      )
  })
};
  
//==============================================================================================================

//ADD SUBCATEGORY-------------------------------------------------------------------------------------------
app.post('/add_sub_category', (req, res) => {
    const category_name = req.body.category_sub;
    const sub_category_name = req.body.sub_category_name;

    getCategories()
        .then(categories => {
            const category = categories.find(cat => cat.cat_name === category_name);
            if (category) {
                return addSubCategory(category.idCat, sub_category_name);
            }
        })
        .then(() => {
            res.redirect('/item_added_conf');
        })
});

const addSubCategory = (idCat, sub_category_name) => {
    return new Promise((resolve, reject) => {
        pool.getConnection((err, conn) => {
            if (err) {
                reject(err);
            } else {
                const query = 'INSERT INTO sub_category (idCat, subCat_name) VALUES (?, ?)';
                const values = [idCat, sub_category_name];

                conn.query(query, values, (err, result) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(result);
                    }
                    conn.release();
                });
            }
        });
    });
};

const getCategories = () => {
    return new Promise((resolve, reject) => {
        pool.getConnection((err, conn) => {
            if (err) {
                reject(err);
            } else {
                const query = 'SELECT * FROM category';

                conn.query(query, (err, results) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(results);
                    }
                    conn.release();
                });
            }
        });
    });
};

// mengecek designer menggunakan AJAX
app.get('/check_subCategory', (req, res) => {
let subCategory = req.query.inputed_subCategory;
let subCategoryTaken = true;
checkSubCategoryExistence(subCategory).then((exists) => {
    subCategoryTaken = (JSON.parse(JSON.stringify(exists))[0]) !==undefined;
      const response = {
          taken: subCategoryTaken
        };
    res.json( response );
  })
  
});

const checkSubCategoryExistence = (added_subCategory) => {
return new Promise((resolve, reject) => {
    pool.query('SELECT idSubCat FROM  sub_category WHERE subCat_name = ?', [added_subCategory], (err, result) => {
        if(err){
            reject (err);
        }
        else{
            resolve(result);
        }
    }
    )
})
};

//==============================================================================================================


//ADD BAG-------------------------------------------------------------------------------------------
  app.get('/get_subcategories', (req, res) => {
    const category = req.query.category;
  
    getSubCategories(category)
      .then(subCategories => {
        res.json({ subCategories });
      });
  });
  
  const addBag2 = (bag_name, length, width, height, color, idSubCat, idBrand, idDes, photoData) => {
    return new Promise((resolve, reject) => {
      const queryBrand = 'SELECT idBrand FROM brand WHERE brand_name = ?';
      const valuesBrand = [idBrand];
  
      pool.query(queryBrand, valuesBrand, (errBrand, resultBrand) => {
        if (errBrand) {
          reject(errBrand);
        } else {
          const idBrand = resultBrand[0].idBrand;
  
          const queryDesigner = 'SELECT idDes FROM designer WHERE des_name = ?';
          const valuesDesigner = [idDes];
  
          pool.query(queryDesigner, valuesDesigner, (errDesigner, resultDesigner) => {
            if (errDesigner) {
              reject(errDesigner);
            } else {
              const idDes = resultDesigner[0].idDes;
  
              const insertQuery = 'INSERT INTO bag (bag_name, length, width, height, color, idSubCat, idBrand, idDes, bag_photo) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)';
              const insertValues = [bag_name, length, width, height, color, idSubCat, idBrand, idDes, photoData];
  
              pool.query(insertQuery, insertValues, (errInsert, resultInsert) => {
                if (errInsert) {
                  reject(errInsert);
                } else {
                  resolve(resultInsert);
                }
              });
            }
          });
        }
      });
    });
  }
  

  app.post('/add_bag', upload.single('bag_photo'), (req, res) => {
    const bag_name = req.body.bag_name;
    const length = req.body.dimension1;
    const width = req.body.dimension2;
    const height = req.body.dimension3;
    const color = req.body.bag_color;
    const idSubCat = req.body.bag_sub_category;
    const idBrand = req.body.select_brand;
    const idDes = req.body.select_designer;
  
    const photoData = fs.readFileSync(req.file.path); // Membaca file foto yang diunggah
  
    addBag2(bag_name, length, width, height, color, idSubCat, idBrand, idDes, photoData)
      .then((resultInsert) => {
        const bagId = resultInsert.insertId; // Mengambil ID tas yang baru saja ditambahkan
  
        // Menambahkan foto ke dalam database dengan ID tas yang baru
        changePhotoBag(bagId, photoData)
          .then(() => {
            // Mengambil foto tas yang baru saja diubah
            getNewPhotoBag(bagId)
              .then((newPhoto) => {
                req.session.photo = JSON.parse(JSON.stringify(newPhoto))[0].bag_photo;
                res.redirect('/item_added_conf');
              })
              .catch((error) => {
                console.error('Failed to get new bag photo:', error);
                res.status(500).send('Internal Server Error');
              });
          })
          .catch((error) => {
            console.error('Failed to change bag photo:', error);
            res.status(500).send('Internal Server Error');
          });
      })
      .catch((error) => {
        console.error('Failed to add bag:', error);
        res.status(500).send('Internal Server Error');
      });
  });

  const getNewPhotoBag = (idBag) => {
    return new Promise((resolve, reject) => {
      pool.query('SELECT bag_photo FROM bag WHERE idBag = ?', [idBag], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
  
  const changePhotoBag = (idBag, photo) => {
    return new Promise((resolve, reject) => {
      pool.query('UPDATE bag SET bag_photo = ? WHERE idBag = ?', [photo, idBag], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });
  };
  
  
  // menampilkan brand di dropdown
  const getBrands = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM brand';
  
          conn.query(query, (err, results) => {
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
            conn.release();
          });
        }
      });
    });
  };
  

  const getDesigners = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM designer';
  
          conn.query(query, (err, results) => {
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
            conn.release();
          });
        }
      });
    });
  };

  const getCategoriesBag = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM category';
  
          conn.query(query, (err, results) => {
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
            conn.release();
          });
        }
      });
    });
  };

  const getSubCategories = (category) => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM sub_category WHERE idCat = ?';
          conn.query(query, [category], (err, results) => {
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
            conn.release();
          });
        }
      });
    });
  };

//==============================================================================================================


//CHANGED_CONF-------------------------------------------------------------------------------------------

app.get('/changed_conf_admin', (req, res) => {
    res.render('changed_conf_admin');
});

//==============================================================================================================


//DATA_ADDED_CONF-------------------------------------------------------------------------------------------

app.get('/data_added_conf', (req, res) => {
    res.render('data_added_conf');
});

//==============================================================================================================


//SET_REVIEW-------------------------------------------------------------------------------------------

app.use(bodyParser.json());

app.get('/set_review', (req, res) => {
  res.render('set_review');
});

let minimalReview = 0;
let rentangNilai = '1-5';
app.post('/set_review', (req, res) => {
  minimalReview = req.body.minimalReview;
  rentangNilai = req.body.rentangNilai;
  let artiNilai = req.body.artiNilai;

  let values = [];

  values = artiNilai.split(';').map(value => value.trim());

  if (rentangNilai === '1-5') {
    values = values.slice(0, 5);
  }

  let reviewValues = values.map(value => [value]);

  pool.query('INSERT INTO review_value (value_desc) VALUES ?', [reviewValues], (err, result) => {
    if (err) {
      console.error('Error inserting data into review_value table:', err);
      res.status(500).json({ error: 'Error inserting data into review_value table' });
    } else {
      res.json({ success: true });
    }
  });
});



//==============================================================================================================


//IMPORT_DATA-------------------------------------------------------------------------------------------
app.get('/import_data', (req, res) => {
  res.render('import_data');
});


app.post('/import_data', upload.single('file_upload'), (req, res) => {
  const csvFile = req.file;
  console.log(csvFile);

  
  pool.getConnection((err, conn) => {
    if (err) {
      console.error('Error connecting to database:', err);
      res.status(500).send('Error connecting to database');
      return;
    }

    fs.createReadStream(csvFile.path)
      .pipe(csvParser())
      .on('data', (row) => {
        console.log(row);
        const bag = {
          bag_name: row.bag_name,
          bag_photo: Buffer.from(row.bag_photo, 'base64'),
          length: row.length,
          width: row.width,
          height: row.height,
          color: row.color,
          idSubCat: row.idSubCat,
          idDes: row.idDes,
          idBrand: row.idBrand
        };

        const query = 'INSERT INTO bag SET ?';
        conn.query(query, bag, (error, results, fields) => {
          if (error) {
            console.error('Error importing data to Bag table:', error);
          }
        });
      })
      .on('end', () => {
        conn.release(); 
        res.redirect('/item_added_conf');
      });
  });
});


//==============================================================================================================


//ADMIN DASHBOARD----------------------------------------------------------------------------------------------

const dashboard_getBrands = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM brand';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
          });
        }
      });
    });
  };
  
  
  const dashboard_getDesigners = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM designer';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
          });
        }
      });
    });
  };
  
  const dashboard_getCategoriesBag = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM category';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
          });
        }
      });
    });
  };
  
  const dashboard_getSubCategories = (category) => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT * FROM `sub_category` WHERE idCat = ?';
          conn.query(query, [category], (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results);
            }
          });
        }
      });
    });
  };
  
  app.get('/dashboard_admin', auth, async (req, res) => {
    try {
      const brands = await dashboard_getBrands();
      const designers = await dashboard_getDesigners();
      const categories = await getCategoriesBag();
      const subCategories = await dashboard_getSubCategories();
      // Additional code to fetch and calculate the required data
      const totalBagCount = await getTotalBagCount();
      const totalCategoryCount = await getTotalCategoryCount();
      const totalSubcategoryCount = await getTotalSubcategoryCount();
      const totalBrandCount = await getTotalBrandCount();
      const totalDesignerCount = await getTotalDesignerCount();
      const lowestReviewBag = await getBagWithLowestReview();
      const lowestReviewCount = await getLowestReviewCount();
      const totalReviewCount = await getTotalReviewCount();
      const highestReviewBag = await getBagWithHighestReview();
      const highestReviewCount = await getHighestReviewCount();
      const lowestReviewValueBag = await getBagWithLowestReviewValue();
      const lowestReviewValue = await getLowestReviewValue();
      const averageReviewValue = await getAverageReviewValue();
      const highestReviewValueBag = await getBagWithHighestReviewValue();
      const highestReviewValue = await getHighestReviewValue();
  
      res.render('dashboard_admin', {
        username: req.session.username,
        brands,
        designers,
        categories,
        subCategories,
        totalBagCount,
        totalCategoryCount,
        totalSubcategoryCount,
        totalBrandCount,
        totalDesignerCount,
        lowestReviewBag,
        lowestReviewCount,
        totalReviewCount,
        highestReviewBag,
        highestReviewCount,
        lowestReviewValueBag,
        lowestReviewValue,
        averageReviewValue,
        highestReviewValueBag,
        highestReviewValue
      });
    } catch (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    }
  });
  
  app.get('/get_subcategories', async (req, res) => {
    const { category } = req.query;
    try {
      const subcategories = await getSubCategories(category);
      res.json(subcategories);
    } catch (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    }
  });
  
  app.get('/getSubCategories', async (req, res) => {
    const { category } = req.query;
  
    try {
      const subCategories = await getSubCategories(category);
  
      res.json({ subCategories });
    } catch (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    }
  });
  const getTotalBagCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT COUNT(*) AS totalBagCount FROM bag';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0].totalBagCount);
            }
          });
        }
      });
    });
  };
  
  const getTotalCategoryCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT COUNT(*) AS totalCategoryCount FROM category';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0].totalCategoryCount);
            }
          });
        }
      });
    });
  };
  
  const getTotalSubcategoryCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT COUNT(*) AS totalSubcategoryCount FROM `sub_category`';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0].totalSubcategoryCount);
            }
          });
        }
      });
    });
  };
  
  const getTotalBrandCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT COUNT(*) AS totalBrandCount FROM brand';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0].totalBrandCount);
            }
          });
        }
      });
    });
  };
  
  const getTotalDesignerCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT COUNT(*) AS totalDesignerCount FROM designer';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0].totalDesignerCount);
            }
          });
        }
      });
    });
  };
  
  const getBagWithLowestReview = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT b.bag_name, COUNT(r.idBag) AS review_count FROM review r JOIN bag b ON r.idBag = b.idBag GROUP BY r.idBag ORDER BY review_count ASC LIMIT 1';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0]);
            }
          });
        }
      });
    });
  };
  
  const getLowestReviewCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT MIN(review_count) AS lowest_review_count FROM (SELECT COUNT(idReview) AS review_count FROM review GROUP BY idBag) AS subquery';
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].lowest_review_count);
            }
          });
        }
      });
    });
  };
  
  const getTotalReviewCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT SUM(review_count) AS total_review_count FROM (SELECT COUNT(idReview) AS review_count FROM review GROUP BY idBag) AS subquery';
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].total_review_count);
            }
          });
        }
      });
    });
  };
  
  const getBagWithHighestReview = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT b.bag_name, COUNT(r.idBag) AS review_count FROM review r JOIN bag b ON r.idBag = b.idBag GROUP BY r.idBag ORDER BY review_count DESC LIMIT 1';
  
          conn.query(query, (err, results) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(results[0]);
            }
          });
        }
      });
    });
  };
  
  const getHighestReviewCount = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = 'SELECT MAX(review_count) AS highest_review_count FROM (SELECT COUNT(idReview) AS review_count FROM review GROUP BY idBag) AS subquery';
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].highest_review_count);
            }
          });
        }
      });
    });
  };
  
  const getBagWithLowestReviewValue = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = `
            SELECT b.bag_name
            FROM bag AS b
            JOIN review AS r ON b.idBag = r.idBag
            ORDER BY r.value ASC
            LIMIT 1
          `;
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].bag_name);
            }
          });
        }
      });
    });
  };
  
  const getLowestReviewValue = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = `
            SELECT MIN(value) AS lowest_review_value
            FROM review
          `;
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].lowest_review_value);
            }
          });
        }
      });
    });
  };
  
  const getAverageReviewValue = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = `
            SELECT AVG(value) AS average_review_value
            FROM review
          `;
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].average_review_value);
            }
          });
        }
      });
    });
  };
  
  const getBagWithHighestReviewValue = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = `
            SELECT b.bag_name
            FROM bag AS b
            JOIN review AS r ON b.idBag = r.idBag
            ORDER BY r.value DESC
            LIMIT 1
          `;
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].bag_name);
            }
          });
        }
      });
    });
  };
  
  const getHighestReviewValue = () => {
    return new Promise((resolve, reject) => {
      pool.getConnection((err, conn) => {
        if (err) {
          reject(err);
        } else {
          const query = `
            SELECT MAX(value) AS highest_review_value
            FROM review
          `;
  
          conn.query(query, (err, result) => {
            conn.release();
            if (err) {
              reject(err);
            } else {
              resolve(result[0].highest_review_value);
            }
          });
        }
      });
    });
  };

//see_report-------------------------------------------------------------------------------------------------------
app.get('/see_report', async (req, res) => {
    try {
      // Query the database to retrieve the necessary data
      const bagQuery = `
        SELECT Bag.bag_name, Category.cat_name, sub_category.subCat_name, Brand.brand_name, Designer.des_name,
        COUNT(Review.idReview) AS bagCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes       
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Bag.idBag
      `;
  
      const categoryQuery = `
        SELECT Category.cat_name, COUNT(Review.idReview) AS ReviewCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Category.idCat
      `;
  
      const subCategoryQuery = `
        SELECT Category.cat_name, sub_category.subCat_name, COUNT(Review.idReview) AS ReviewCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY sub_category.idSubCat
      `;
  
      const brandQuery = `
        SELECT Brand.brand_name, COUNT(Review.idReview) AS ReviewCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Brand.idBrand
      `;
      
      const designerQuery = `
        SELECT Designer.des_name, COUNT(Review.idReview) AS ReviewCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Designer.idDes
      `;
  
      const conn = await dbConnect(); // Connect to the database
  
      // Retrieve data for bags report
      const bagResults = await new Promise((resolve, reject) => {
        conn.query(bagQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const bags = bagResults.map(row => ({
        bag_name: row.bag_name,
        cat_name: row.cat_name,
        subCat_name: row.subCat_name,
        brand_name: row.brand_name,
        des_name: row.des_name,
        bagCount: row.bagCount,
        reviewValueAvg: row.reviewValueAvg,
      }));
  
      // Retrieve data for category report
      const categoryResults = await new Promise((resolve, reject) => {
        conn.query(categoryQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const categoryReport = categoryResults.map(row => ({
        cat_name: row.cat_name,
        ReviewCount: row.ReviewCount,
        reviewValueAvg: row.reviewValueAvg,
      }));
  
      // Retrieve data for sub-category report
      const subCategoryResults = await new Promise((resolve, reject) => {
        conn.query(subCategoryQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const subCategoryReport = subCategoryResults.map(row => ({
        cat_name: row.cat_name,
        subCat_name: row.subCat_name,
        ReviewCount: row.ReviewCount,
        reviewValueAvg: row.reviewValueAvg,
      }));
  
      // Retrieve data for brand report
      const brandResults = await new Promise((resolve, reject) => {
        conn.query(brandQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const brandReport = brandResults.map(row => ({
        brand_name: row.brand_name,
        ReviewCount: row.ReviewCount,
        reviewValueAvg: row.reviewValueAvg,
      }));
      
      // Retrieve data for designer report
      const designerResults = await new Promise((resolve, reject) => {
        conn.query(designerQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const designerReport = designerResults.map(row => ({
        des_name: row.des_name,
        ReviewCount: row.ReviewCount,
        reviewValueAvg: row.reviewValueAvg,
      }));
  
      res.render('see_report', { bags, categoryReport, subCategoryReport, brandReport, designerReport }); // Render the see_report.ejs template with the retrieved data
    } catch (error) {
      console.error(error);
      res.status(500).send('Internal Server Error');
    }
  });
  
  import { PDFDocument, StandardFonts, rgb } from 'pdf-lib';
  import { fileURLToPath } from 'url';
  import { dirname } from 'path';
  
  app.post('/generate_report_pdf', async (req, res) => {
    try {
      const conn = await dbConnect(); // Connect to the database
  
      const bagQuery = `
        SELECT Bag.bag_name, Category.cat_name, sub_category.subCat_name, Brand.brand_name, Designer.des_name,
        COUNT(Review.idReview) AS bagCount, ROUND(AVG(Review.value), 1) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes       
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Bag.idBag
      `;
  
      const bags = await new Promise((resolve, reject) => {
        conn.query(bagQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const categoryQuery = `
        SELECT Category.cat_name, COUNT(Review.idReview) AS ReviewCount, AVG(Review.value) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Category.idCat
      `;
  
      const categoryReport = await new Promise((resolve, reject) => {
        conn.query(categoryQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const subCategoryQuery = `
        SELECT Category.cat_name, sub_category.subCat_name, COUNT(Review.idReview) AS ReviewCount, AVG(Review.value) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY sub_category.idSubCat
      `;
  
      const subCategoryReport = await new Promise((resolve, reject) => {
        conn.query(subCategoryQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const brandQuery = `
        SELECT Brand.brand_name, COUNT(Review.idReview) AS ReviewCount, AVG(Review.value) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Brand.idBrand
      `;
  
      const brandReport = await new Promise((resolve, reject) => {
        conn.query(brandQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const designerQuery = `
        SELECT Designer.des_name, COUNT(Review.idReview) AS ReviewCount, AVG(Review.value) AS reviewValueAvg
        FROM Category
        JOIN sub_category ON Category.idCat = sub_category.idCat
        JOIN Bag ON Bag.idSubCat = sub_category.idSubCat
        JOIN Brand ON Brand.idBrand = Bag.idBrand
        JOIN Designer ON Designer.idDes = Bag.idDes
        JOIN Review ON Bag.idBag = Review.idBag
        GROUP BY Designer.idDes
      `;
  
      const designerReport = await new Promise((resolve, reject) => {
        conn.query(designerQuery, (err, rows) => {
          if (err) {
            reject(err);
          } else {
            resolve(rows);
          }
        });
      });
  
      const pdfDoc = await PDFDocument.create();
      const page = null;
  
      // Set the font for the page
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
  
      const unsortedBagTable = `Unsorted Bag Table:\n`
        + `${bags.map(row => `${row.bag_name}, ${row.cat_name}, ${row.subCat_name}, ${row.brand_name}, ${row.des_name}, ${row.bagCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      const unsortedCategoryTable = `Unsorted Category Table:\n`
        + `${categoryReport.map(row => `${row.cat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      const unsortedSubcategoryTable = `Unsorted Subcategory Table:\n`
        + `${subCategoryReport.map(row => `${row.cat_name}, ${row.subCat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      const unsortedBrandTable = `Unsorted Brand Table:\n`
        + `${brandReport.map(row => `${row.brand_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      const unsortedDesignerTable = `Unsorted Designer Table:\n`
        + `${designerReport.map(row => `${row.des_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      const sortedBagByName = [...bags].sort((a, b) => a.bag_name.localeCompare(b.bag_name));
      const sortedCategoryByName = [...categoryReport].sort((a, b) => a.cat_name.localeCompare(b.cat_name));
      const sortedSubcategoryByName = [...subCategoryReport].sort((a, b) => a.subCat_name.localeCompare(b.subCat_name));
      const sortedBrandByName = [...brandReport].sort((a, b) => a.brand_name.localeCompare(b.brand_name));
      const sortedDesignerByName = [...designerReport].sort((a, b) => a.des_name.localeCompare(b.des_name));
  
      // Sort the tables by review count in descending order (high to low)
      const sortedBagByReviewCount = [...bags].sort((a, b) => b.bagCount - a.bagCount);
      const sortedCategoryByReviewCount = [...categoryReport].sort((a, b) => b.ReviewCount - a.ReviewCount);
      const sortedSubcategoryByReviewCount = [...subCategoryReport].sort((a, b) => b.ReviewCount - a.ReviewCount);
      const sortedBrandByReviewCount = [...brandReport].sort((a, b) => b.ReviewCount - a.ReviewCount);
      const sortedDesignerByReviewCount = [...designerReport].sort((a, b) => b.ReviewCount - a.ReviewCount);
  
      // Sort the tables by average review value in descending order (high to low)
      const sortedBagByReviewValue = [...bags].sort((a, b) => b.reviewValueAvg - a.reviewValueAvg);
      const sortedCategoryByReviewValue = [...categoryReport].sort((a, b) => b.reviewValueAvg - a.reviewValueAvg);
      const sortedSubcategoryByReviewValue = [...subCategoryReport].sort((a, b) => b.reviewValueAvg - a.reviewValueAvg);
      const sortedBrandByReviewValue = [...brandReport].sort((a, b) => b.reviewValueAvg - a.reviewValueAvg);
      const sortedDesignerByReviewValue = [...designerReport].sort((a, b) => b.reviewValueAvg - a.reviewValueAvg);
  
      const sortedTables = `Sorted Tables:\n`
        + `Sorted Bag Table by Name (Ascending):\n`
        + `${sortedBagByName.map(row => `${row.bag_name}, ${row.cat_name}, ${row.subCat_name}, ${row.brand_name}, ${row.des_name}, ${row.bagCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Bag Table by Review Count (Highest to Lowest):\n`
        + `${sortedBagByReviewCount.map(row => `${row.bag_name}, ${row.cat_name}, ${row.subCat_name}, ${row.brand_name}, ${row.des_name}, ${row.bagCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Bag Table by Average Review Value (Highest to Lowest):\n`
        + `${sortedBagByReviewValue.map(row => `${row.bag_name}, ${row.cat_name}, ${row.subCat_name}, ${row.brand_name}, ${row.des_name}, ${row.bagCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Category Table by Name (Ascending):\n`
        + `${sortedCategoryByName.map(row => `${row.cat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Category Table by Review Count (Highest to Lowest):\n`
        + `${sortedCategoryByReviewCount.map(row => `${row.cat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Category Table by Average Review Value (Highest to Lowest):\n`
        + `${sortedCategoryByReviewValue.map(row => `${row.cat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Subcategory Table by Name (Ascending):\n`
        + `${sortedSubcategoryByName.map(row => `${row.cat_name}, ${row.subCat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Subcategory Table by Review Count (Highest to Lowest):\n`
        + `${sortedSubcategoryByReviewCount.map(row => `${row.cat_name}, ${row.subCat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Subcategory Table by Average Review Value (Highest to Lowest):\n`
        + `${sortedSubcategoryByReviewValue.map(row => `${row.cat_name}, ${row.subCat_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Brand Table by Name (Ascending):\n`
        + `${sortedBrandByName.map(row => `${row.brand_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Brand Table by Review Count (Highest to Lowest):\n`
        + `${sortedBrandByReviewCount.map(row => `${row.brand_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Brand Table by Average Review Value (Highest to Lowest):\n`
        + `${sortedBrandByReviewValue.map(row => `${row.brand_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Designer Table by Name (Ascending):\n`
        + `${sortedDesignerByName.map(row => `${row.des_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Designer Table by Review Count (Highest to Lowest):\n`
        + `${sortedDesignerByReviewCount.map(row => `${row.des_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`
        + `Sorted Designer Table by Average Review Value (Highest to Lowest):\n`
        + `${sortedDesignerByReviewValue.map(row => `${row.des_name}, ${row.ReviewCount}, ${row.reviewValueAvg}`).join('\n')}\n\n`;
  
      // Generate the report content
      const content = `Report!!!\n\n`
        + unsortedBagTable
        + unsortedCategoryTable
        + unsortedSubcategoryTable
        + unsortedBrandTable
        + unsortedDesignerTable
        + sortedTables;
  
      // Calculate the height of the content
  // Set the page size and margins
  const pageWidth = 720;
  const pageHeight = 800;
  const margin = 50;
  let currentPage = null;
  let y = pageHeight - margin;
  let isFirstPage = true;
  
  // Calculate the height of the content
  const textHeight = font.heightAtSize(12);
  const lineSpacing = 10;
  const availableHeight = pageHeight - margin * 2;
  const maxLinesPerPage = Math.floor(availableHeight / (textHeight + lineSpacing));
  
  // Split the content into lines
  const textLines = content.split('\n');
  
  // Iterate over the lines and draw them on the pages
  let linesDrawn = 0;
  
  for (const line of textLines) {
    if (linesDrawn === maxLinesPerPage || currentPage === null) {
      // Skip the first page if there is no content to be drawn
      if (isFirstPage && linesDrawn === 0) {
        isFirstPage = false;
      } else {
        // Create a new page when the current page is full or if there is no current page
        currentPage = pdfDoc.addPage([pageWidth, pageHeight]);
        y = currentPage.getHeight() - margin;
      }
      linesDrawn = 0;
    }
  
    if (currentPage) {
      currentPage.drawText(line, {
        x: margin,
        y,
        size: 12,
        font,
      });
  
      y -= textHeight + lineSpacing;
      linesDrawn++;
    }
  }
  // Save the PDF document to a file
  const pdfBytes = await pdfDoc.save();
  const fileName = 'report.pdf';
  const currentFilePath = fileURLToPath(import.meta.url);
  // Resolve the directory path
  const currentDirPath = dirname(currentFilePath);
  const filePath = `${currentDirPath}/${fileName}`;
  
  fs.writeFileSync(filePath, pdfBytes);
  
  res.download(filePath, 'report.pdf', (err) => {
    if (err) {
      console.error(err);
      res.status(500).send('Internal Server Error');
    }
  
    // Delete the generated file after download
    fs.unlinkSync(filePath);
  });
    } catch (error) {
      console.error(error);
      res.status(500).send('Internal Server Error');
    }
  });
  